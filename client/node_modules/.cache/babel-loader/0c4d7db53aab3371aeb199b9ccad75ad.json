{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar debug = require('./debug');\n\nvar RedisClient = require('../').RedisClient;\n\nvar Command = require('./command');\n\nvar noop = function noop() {};\n/**********************************************\nAll documented and exposed API belongs in here\n**********************************************/\n// Redirect calls to the appropriate function and use to send arbitrary / not supported commands\n\n\nRedisClient.prototype.send_command = RedisClient.prototype.sendCommand = function (command, args, callback) {\n  // Throw to fail early instead of relying in order in this case\n  if (typeof command !== 'string') {\n    throw new TypeError('Wrong input type \"' + (command !== null && command !== undefined ? command.constructor.name : command) + '\" for command name');\n  }\n\n  command = command.toLowerCase();\n\n  if (!Array.isArray(args)) {\n    if (args === undefined || args === null) {\n      args = [];\n    } else if (typeof args === 'function' && callback === undefined) {\n      callback = args;\n      args = [];\n    } else {\n      throw new TypeError('Wrong input type \"' + args.constructor.name + '\" for args');\n    }\n  }\n\n  if (typeof callback !== 'function' && callback !== undefined) {\n    throw new TypeError('Wrong input type \"' + (callback !== null ? callback.constructor.name : 'null') + '\" for callback function');\n  } // Using the raw multi command is only possible with this function\n  // If the command is not yet added to the client, the internal function should be called right away\n  // Otherwise we need to redirect the calls to make sure the internal functions don't get skipped\n  // The internal functions could actually be used for any non hooked function\n  // but this might change from time to time and at the moment there's no good way to distinguish them\n  // from each other, so let's just do it do it this way for the time being\n\n\n  if (command === 'multi' || typeof this[command] !== 'function') {\n    return this.internal_send_command(new Command(command, args, callback));\n  }\n\n  if (typeof callback === 'function') {\n    args = args.concat([callback]); // Prevent manipulating the input array\n  }\n\n  return this[command].apply(this, args);\n};\n\nRedisClient.prototype.end = function (flush) {\n  // Flush queue if wanted\n  if (flush) {\n    this.flush_and_error({\n      message: 'Connection forcefully ended and command aborted.',\n      code: 'NR_CLOSED'\n    });\n  } else if (arguments.length === 0) {\n    this.warn('Using .end() without the flush parameter is deprecated and throws from v.3.0.0 on.\\n' + 'Please check the doku (https://github.com/NodeRedis/node_redis) and explictly use flush.');\n  } // Clear retry_timer\n\n\n  if (this.retry_timer) {\n    clearTimeout(this.retry_timer);\n    this.retry_timer = null;\n  }\n\n  this.stream.removeAllListeners();\n  this.stream.on('error', noop);\n  this.connected = false;\n  this.ready = false;\n  this.closing = true;\n  return this.stream.destroySoon();\n};\n\nRedisClient.prototype.unref = function () {\n  if (this.connected) {\n    debug(\"Unref'ing the socket connection\");\n    this.stream.unref();\n  } else {\n    debug('Not connected yet, will unref later');\n    this.once('connect', function () {\n      this.unref();\n    });\n  }\n};\n\nRedisClient.prototype.duplicate = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  var existing_options = utils.clone(this.options);\n  options = utils.clone(options);\n\n  for (var elem in options) {\n    existing_options[elem] = options[elem];\n  }\n\n  var client = new RedisClient(existing_options);\n  client.selected_db = options.db || this.selected_db;\n\n  if (typeof callback === 'function') {\n    var ready_listener = function ready_listener() {\n      callback(null, client);\n      client.removeAllListeners(error_listener);\n    };\n\n    var error_listener = function error_listener(err) {\n      callback(err);\n      client.end(true);\n    };\n\n    client.once('ready', ready_listener);\n    client.once('error', error_listener);\n    return;\n  }\n\n  return client;\n};","map":{"version":3,"sources":["/home/daniel/Projects/critter-catcher/node_modules/redis/lib/extendedApi.js"],"names":["utils","require","debug","RedisClient","Command","noop","prototype","send_command","sendCommand","command","args","callback","TypeError","undefined","constructor","name","toLowerCase","Array","isArray","internal_send_command","concat","apply","end","flush","flush_and_error","message","code","arguments","length","warn","retry_timer","clearTimeout","stream","removeAllListeners","on","connected","ready","closing","destroySoon","unref","once","duplicate","options","existing_options","clone","elem","client","selected_db","db","ready_listener","error_listener","err"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar debug = require('./debug');\nvar RedisClient = require('../').RedisClient;\nvar Command = require('./command');\nvar noop = function () {};\n\n/**********************************************\nAll documented and exposed API belongs in here\n**********************************************/\n\n// Redirect calls to the appropriate function and use to send arbitrary / not supported commands\nRedisClient.prototype.send_command = RedisClient.prototype.sendCommand = function (command, args, callback) {\n    // Throw to fail early instead of relying in order in this case\n    if (typeof command !== 'string') {\n        throw new TypeError('Wrong input type \"' + (command !== null && command !== undefined ? command.constructor.name : command) + '\" for command name');\n    }\n    command = command.toLowerCase();\n    if (!Array.isArray(args)) {\n        if (args === undefined || args === null) {\n            args = [];\n        } else if (typeof args === 'function' && callback === undefined) {\n            callback = args;\n            args = [];\n        } else {\n            throw new TypeError('Wrong input type \"' + args.constructor.name + '\" for args');\n        }\n    }\n    if (typeof callback !== 'function' && callback !== undefined) {\n        throw new TypeError('Wrong input type \"' + (callback !== null ? callback.constructor.name : 'null') + '\" for callback function');\n    }\n\n    // Using the raw multi command is only possible with this function\n    // If the command is not yet added to the client, the internal function should be called right away\n    // Otherwise we need to redirect the calls to make sure the internal functions don't get skipped\n    // The internal functions could actually be used for any non hooked function\n    // but this might change from time to time and at the moment there's no good way to distinguish them\n    // from each other, so let's just do it do it this way for the time being\n    if (command === 'multi' || typeof this[command] !== 'function') {\n        return this.internal_send_command(new Command(command, args, callback));\n    }\n    if (typeof callback === 'function') {\n        args = args.concat([callback]); // Prevent manipulating the input array\n    }\n    return this[command].apply(this, args);\n};\n\nRedisClient.prototype.end = function (flush) {\n    // Flush queue if wanted\n    if (flush) {\n        this.flush_and_error({\n            message: 'Connection forcefully ended and command aborted.',\n            code: 'NR_CLOSED'\n        });\n    } else if (arguments.length === 0) {\n        this.warn(\n            'Using .end() without the flush parameter is deprecated and throws from v.3.0.0 on.\\n' +\n            'Please check the doku (https://github.com/NodeRedis/node_redis) and explictly use flush.'\n        );\n    }\n    // Clear retry_timer\n    if (this.retry_timer) {\n        clearTimeout(this.retry_timer);\n        this.retry_timer = null;\n    }\n    this.stream.removeAllListeners();\n    this.stream.on('error', noop);\n    this.connected = false;\n    this.ready = false;\n    this.closing = true;\n    return this.stream.destroySoon();\n};\n\nRedisClient.prototype.unref = function () {\n    if (this.connected) {\n        debug(\"Unref'ing the socket connection\");\n        this.stream.unref();\n    } else {\n        debug('Not connected yet, will unref later');\n        this.once('connect', function () {\n            this.unref();\n        });\n    }\n};\n\nRedisClient.prototype.duplicate = function (options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    var existing_options = utils.clone(this.options);\n    options = utils.clone(options);\n    for (var elem in options) {\n        existing_options[elem] = options[elem];\n    }\n    var client = new RedisClient(existing_options);\n    client.selected_db = options.db || this.selected_db;\n    if (typeof callback === 'function') {\n        var ready_listener = function () {\n            callback(null, client);\n            client.removeAllListeners(error_listener);\n        };\n        var error_listener = function (err) {\n            callback(err);\n            client.end(true);\n        };\n        client.once('ready', ready_listener);\n        client.once('error', error_listener);\n        return;\n    }\n    return client;\n};\n"]},"metadata":{},"sourceType":"script"}