{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar util = require('util');\n\nvar utils = require('./lib/utils');\n\nvar Command = require('./lib/command');\n\nvar Queue = require('denque');\n\nvar errorClasses = require('./lib/customErrors');\n\nvar EventEmitter = require('events');\n\nvar Parser = require('redis-parser');\n\nvar RedisErrors = require('redis-errors');\n\nvar commands = require('redis-commands');\n\nvar debug = require('./lib/debug');\n\nvar unifyOptions = require('./lib/createClient');\n\nvar SUBSCRIBE_COMMANDS = {\n  subscribe: true,\n  unsubscribe: true,\n  psubscribe: true,\n  punsubscribe: true\n};\n\nfunction noop() {}\n\nfunction handle_detect_buffers_reply(reply, command, buffer_args) {\n  if (buffer_args === false || this.message_buffers) {\n    // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n    // If this command did not use Buffer arguments, then convert the reply to Strings here.\n    reply = utils.reply_to_strings(reply);\n  }\n\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG); // Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\n\nfunction RedisClient(options, stream) {\n  // Copy the options so they are not mutated\n  options = utils.clone(options);\n  EventEmitter.call(this);\n  var cnx_options = {};\n  var self = this;\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n  for (var tls_option in options.tls) {\n    cnx_options[tls_option] = options.tls[tls_option]; // Copy the tls options into the general options to make sure the address is set right\n\n    if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n      options[tls_option] = options.tls[tls_option];\n    }\n  }\n\n  if (stream) {\n    // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n    // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n    options.stream = stream;\n    this.address = '\"Private stream\"';\n  } else if (options.path) {\n    cnx_options.path = options.path;\n    this.address = options.path;\n  } else {\n    cnx_options.port = +options.port || 6379;\n    cnx_options.host = options.host || '127.0.0.1';\n    cnx_options.family = !options.family && net.isIP(cnx_options.host) || (options.family === 'IPv6' ? 6 : 4);\n    this.address = cnx_options.host + ':' + cnx_options.port;\n  }\n\n  this.connection_options = cnx_options;\n  this.connection_id = RedisClient.connection_id++;\n  this.connected = false;\n  this.ready = false;\n\n  if (options.socket_keepalive === undefined) {\n    options.socket_keepalive = true;\n  }\n\n  if (options.socket_initial_delay === undefined) {\n    options.socket_initial_delay = 0; // set default to 0, which is aligned to https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay\n  }\n\n  for (var command in options.rename_commands) {\n    options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n  }\n\n  options.return_buffers = !!options.return_buffers;\n  options.detect_buffers = !!options.detect_buffers; // Override the detect_buffers setting if return_buffers is active and print a warning\n\n  if (options.return_buffers && options.detect_buffers) {\n    self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n    options.detect_buffers = false;\n  }\n\n  if (options.detect_buffers) {\n    // We only need to look at the arguments if we do not know what we have to return\n    this.handle_reply = handle_detect_buffers_reply;\n  }\n\n  this.should_buffer = false;\n  this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n\n  this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n\n  this.pipeline_queue = new Queue(); // Holds all pipelined commands\n  // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n  // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n\n  this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n\n  this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n  this.initialize_retry_vars();\n  this.pub_sub_mode = 0;\n  this.subscription_set = {};\n  this.monitoring = false;\n  this.message_buffers = false;\n  this.closing = false;\n  this.server_info = {};\n  this.auth_pass = options.auth_pass || options.password;\n  this.selected_db = options.db; // Save the selected db here, used when reconnecting\n\n  this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n\n  this.pipeline = false;\n  this.sub_commands_left = 0;\n  this.times_connected = 0;\n  this.buffers = options.return_buffers || options.detect_buffers;\n  this.options = options;\n  this.reply = 'ON'; // Returning replies is the default\n\n  this.create_stream(); // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n\n  this.on('newListener', function (event) {\n    if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n      this.reply_parser.optionReturnBuffers = true;\n      this.message_buffers = true;\n      this.handle_reply = handle_detect_buffers_reply;\n    }\n  });\n}\n\nutil.inherits(RedisClient, EventEmitter);\nRedisClient.connection_id = 0;\n\nfunction create_parser(self) {\n  return new Parser({\n    returnReply: function returnReply(data) {\n      self.return_reply(data);\n    },\n    returnError: function returnError(err) {\n      // Return a ReplyError to indicate Redis returned an error\n      self.return_error(err);\n    },\n    returnFatalError: function returnFatalError(err) {\n      // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n      // Note: the execution order is important. First flush and emit, then create the stream\n      err.message += '. Please report this.';\n      self.ready = false;\n      self.flush_and_error({\n        message: 'Fatal error encountered. Command aborted.',\n        code: 'NR_FATAL'\n      }, {\n        error: err,\n        queues: ['command_queue']\n      });\n      self.emit('error', err);\n      self.create_stream();\n    },\n    returnBuffers: self.buffers || self.message_buffers,\n    stringNumbers: self.options.string_numbers || false\n  });\n}\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\n\n\nRedisClient.prototype.create_stream = function () {\n  var self = this; // Init parser\n\n  this.reply_parser = create_parser(this);\n\n  if (this.options.stream) {\n    // Only add the listeners once in case of a reconnect try (that won't work)\n    if (this.stream) {\n      return;\n    }\n\n    this.stream = this.options.stream;\n  } else {\n    // On a reconnect destroy the former stream and retry\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n    }\n    /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n    if (this.options.tls) {\n      this.stream = tls.connect(this.connection_options);\n    } else {\n      this.stream = net.createConnection(this.connection_options);\n    }\n  }\n\n  if (this.options.connect_timeout) {\n    this.stream.setTimeout(this.connect_timeout, function () {\n      // Note: This is only tested if a internet connection is established\n      self.retry_totaltime = self.connect_timeout;\n      self.connection_gone('timeout');\n    });\n  }\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n\n\n  var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n  this.stream.once(connect_event, function () {\n    this.removeAllListeners('timeout');\n    self.times_connected++;\n    self.on_connect();\n  });\n  this.stream.on('data', function (buffer_from_socket) {\n    // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n    debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n\n    self.reply_parser.execute(buffer_from_socket);\n  });\n  this.stream.on('error', function (err) {\n    self.on_error(err);\n  });\n  this.stream.once('close', function (hadError) {\n    self.connection_gone('close');\n  });\n  this.stream.once('end', function () {\n    self.connection_gone('end');\n  });\n  this.stream.on('drain', function () {\n    self.drain();\n  });\n  this.stream.setNoDelay(); // Fire the command before redis is connected to be sure it's the first fired command\n\n  if (this.auth_pass !== undefined) {\n    this.ready = true; // Fail silently as we might not be able to connect\n\n    this.auth(this.auth_pass, function (err) {\n      if (err && err.code !== 'UNCERTAIN_STATE') {\n        self.emit('error', err);\n      }\n    });\n    this.ready = false;\n  }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n\n  return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n  this.retry_timer = null;\n  this.retry_totaltime = 0;\n  this.retry_delay = 200;\n  this.retry_backoff = 1.7;\n  this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n  var self = this; // Warn on the next tick. Otherwise no event listener can be added\n  // for warnings that are emitted in the redis client constructor\n\n  process.nextTick(function () {\n    if (self.listeners('warning').length !== 0) {\n      self.emit('warning', msg);\n    } else {\n      console.warn('node_redis:', msg);\n    }\n  });\n}; // Flush provided queues, erroring any items with a callback first\n\n\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n  options = options || {};\n  var aggregated_errors = [];\n  var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n\n  for (var i = 0; i < queue_names.length; i++) {\n    // If the command was fired it might have been processed so far\n    if (queue_names[i] === 'command_queue') {\n      error_attributes.message += ' It might have been processed.';\n    } else {\n      // As the command_queue is flushed first, remove this for the offline queue\n      error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n    } // Don't flush everything from the queue\n\n\n    for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n      var err = new errorClasses.AbortError(error_attributes);\n\n      if (command_obj.error) {\n        err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n      }\n\n      err.command = command_obj.command.toUpperCase();\n\n      if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n      }\n\n      if (options.error) {\n        err.origin = options.error;\n      }\n\n      if (typeof command_obj.callback === 'function') {\n        command_obj.callback(err);\n      } else {\n        aggregated_errors.push(err);\n      }\n    }\n  } // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n\n\n  if (exports.debug_mode && aggregated_errors.length) {\n    var error;\n\n    if (aggregated_errors.length === 1) {\n      error = aggregated_errors[0];\n    } else {\n      error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n      error = new errorClasses.AggregateError(error_attributes);\n      error.errors = aggregated_errors;\n    }\n\n    this.emit('error', error);\n  }\n};\n\nRedisClient.prototype.on_error = function (err) {\n  if (this.closing) {\n    return;\n  }\n\n  err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n  debug(err.message);\n  this.connected = false;\n  this.ready = false; // Only emit the error if the retry_strategy option is not set\n\n  if (!this.options.retry_strategy) {\n    this.emit('error', err);\n  } // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n  // then we should try to reconnect.\n\n\n  this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n  debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n  this.connected = true;\n  this.ready = false;\n  this.emitted_end = false;\n  this.stream.setKeepAlive(this.options.socket_keepalive, this.options.socket_initial_delay);\n  this.stream.setTimeout(0);\n  this.emit('connect');\n  this.initialize_retry_vars();\n\n  if (this.options.no_ready_check) {\n    this.on_ready();\n  } else {\n    this.ready_check();\n  }\n};\n\nRedisClient.prototype.on_ready = function () {\n  var self = this;\n  debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n  this.ready = true;\n\n  this.cork = function () {\n    self.pipeline = true;\n\n    if (self.stream.cork) {\n      self.stream.cork();\n    }\n  };\n\n  this.uncork = function () {\n    if (self.fire_strings) {\n      self.write_strings();\n    } else {\n      self.write_buffers();\n    }\n\n    self.pipeline = false;\n    self.fire_strings = true;\n\n    if (self.stream.uncork) {\n      // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n      self.stream.uncork();\n    }\n  }; // Restore modal commands from previous connection. The order of the commands is important\n\n\n  if (this.selected_db !== undefined) {\n    this.internal_send_command(new Command('select', [this.selected_db]));\n  }\n\n  if (this.monitoring) {\n    // Monitor has to be fired before pub sub commands\n    this.internal_send_command(new Command('monitor', []));\n  }\n\n  var callback_count = Object.keys(this.subscription_set).length;\n\n  if (!this.options.disable_resubscribing && callback_count) {\n    // only emit 'ready' when all subscriptions were made again\n    // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n    // We know we are ready as soon as all commands were fired\n    var callback = function callback() {\n      callback_count--;\n\n      if (callback_count === 0) {\n        self.emit('ready');\n      }\n    };\n\n    debug('Sending pub/sub on_ready commands');\n\n    for (var key in this.subscription_set) {\n      var command = key.slice(0, key.indexOf('_'));\n      var args = this.subscription_set[key];\n      this[command]([args], callback);\n    }\n\n    this.send_offline_queue();\n    return;\n  }\n\n  this.send_offline_queue();\n  this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n  if (err) {\n    if (err.message === \"ERR unknown command 'info'\") {\n      this.on_ready();\n      return;\n    }\n\n    err.message = 'Ready check failed: ' + err.message;\n    this.emit('error', err);\n    return;\n  }\n  /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n\n\n  if (!res) {\n    debug('The info command returned without any data.');\n    this.on_ready();\n    return;\n  }\n\n  if (!this.server_info.loading || this.server_info.loading === '0') {\n    // If the master_link_status exists but the link is not up, try again after 50 ms\n    if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n      this.server_info.loading_eta_seconds = 0.05;\n    } else {\n      // Eta loading should change\n      debug('Redis server ready.');\n      this.on_ready();\n      return;\n    }\n  }\n\n  var retry_time = +this.server_info.loading_eta_seconds * 1000;\n\n  if (retry_time > 1000) {\n    retry_time = 1000;\n  }\n\n  debug('Redis server still loading, trying again in ' + retry_time);\n  setTimeout(function (self) {\n    self.ready_check();\n  }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n  var self = this;\n  debug('Checking server ready state...'); // Always fire this info command as first command even if other commands are already queued up\n\n  this.ready = true;\n  this.info(function (err, res) {\n    self.on_info_cmd(err, res);\n  });\n  this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n  for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n    debug('Sending offline command: ' + command_obj.command);\n    this.internal_send_command(command_obj);\n  }\n\n  this.drain();\n};\n\nvar retry_connection = function retry_connection(self, error) {\n  debug('Retrying connection...');\n  var reconnect_params = {\n    delay: self.retry_delay,\n    attempt: self.attempts,\n    error: error\n  };\n\n  if (self.options.camel_case) {\n    reconnect_params.totalRetryTime = self.retry_totaltime;\n    reconnect_params.timesConnected = self.times_connected;\n  } else {\n    reconnect_params.total_retry_time = self.retry_totaltime;\n    reconnect_params.times_connected = self.times_connected;\n  }\n\n  self.emit('reconnecting', reconnect_params);\n  self.retry_totaltime += self.retry_delay;\n  self.attempts += 1;\n  self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n  self.create_stream();\n  self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n  // If a retry is already in progress, just let that happen\n  if (this.retry_timer) {\n    return;\n  }\n\n  error = error || null;\n  debug('Redis connection is gone from ' + why + ' event.');\n  this.connected = false;\n  this.ready = false; // Deactivate cork to work with the offline queue\n\n  this.cork = noop;\n  this.uncork = noop;\n  this.pipeline = false;\n  this.pub_sub_mode = 0; // since we are collapsing end and close, users don't expect to be called twice\n\n  if (!this.emitted_end) {\n    this.emit('end');\n    this.emitted_end = true;\n  } // If this is a requested shutdown, then don't retry\n\n\n  if (this.closing) {\n    debug('Connection ended by quit / end command, not retrying.');\n    this.flush_and_error({\n      message: 'Stream connection ended and command aborted.',\n      code: 'NR_CLOSED'\n    }, {\n      error: error\n    });\n    return;\n  }\n\n  if (typeof this.options.retry_strategy === 'function') {\n    var retry_params = {\n      attempt: this.attempts,\n      error: error\n    };\n\n    if (this.options.camel_case) {\n      retry_params.totalRetryTime = this.retry_totaltime;\n      retry_params.timesConnected = this.times_connected;\n    } else {\n      retry_params.total_retry_time = this.retry_totaltime;\n      retry_params.times_connected = this.times_connected;\n    }\n\n    this.retry_delay = this.options.retry_strategy(retry_params);\n\n    if (typeof this.retry_delay !== 'number') {\n      // Pass individual error through\n      if (this.retry_delay instanceof Error) {\n        error = this.retry_delay;\n      }\n\n      var errorMessage = 'Redis connection in broken state: retry aborted.';\n      this.flush_and_error({\n        message: errorMessage,\n        code: 'CONNECTION_BROKEN'\n      }, {\n        error: error\n      });\n      var retryError = new Error(errorMessage);\n      retryError.code = 'CONNECTION_BROKEN';\n\n      if (error) {\n        retryError.origin = error;\n      }\n\n      this.end(false);\n      this.emit('error', retryError);\n      return;\n    }\n  }\n\n  if (this.retry_totaltime >= this.connect_timeout) {\n    var message = 'Redis connection in broken state: connection timeout exceeded.';\n    this.flush_and_error({\n      message: message,\n      code: 'CONNECTION_BROKEN'\n    }, {\n      error: error\n    });\n    var err = new Error(message);\n    err.code = 'CONNECTION_BROKEN';\n\n    if (error) {\n      err.origin = error;\n    }\n\n    this.end(false);\n    this.emit('error', err);\n    return;\n  } // Retry commands after a reconnect instead of throwing an error. Use this with caution\n\n\n  if (this.options.retry_unfulfilled_commands) {\n    this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n    this.command_queue.clear();\n  } else if (this.command_queue.length !== 0) {\n    this.flush_and_error({\n      message: 'Redis connection lost and command aborted.',\n      code: 'UNCERTAIN_STATE'\n    }, {\n      error: error,\n      queues: ['command_queue']\n    });\n  }\n\n  if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n    // Do not exceed the maximum\n    this.retry_delay = this.connect_timeout - this.retry_totaltime;\n  }\n\n  debug('Retry connection in ' + this.retry_delay + ' ms');\n  this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n  var command_obj = this.command_queue.shift();\n\n  if (command_obj.error) {\n    err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n  }\n\n  err.command = command_obj.command.toUpperCase();\n\n  if (command_obj.args && command_obj.args.length) {\n    err.args = command_obj.args;\n  } // Count down pub sub mode if in entering modus\n\n\n  if (this.pub_sub_mode > 1) {\n    this.pub_sub_mode--;\n  }\n\n  var match = err.message.match(utils.err_code); // LUA script could return user errors that don't behave like all other errors!\n\n  if (match) {\n    err.code = match[1];\n  }\n\n  utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n  this.should_buffer = false;\n};\n\nfunction normal_reply(self, reply) {\n  var command_obj = self.command_queue.shift();\n\n  if (typeof command_obj.callback === 'function') {\n    if (command_obj.command !== 'exec') {\n      reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n    }\n\n    command_obj.callback(null, reply);\n  } else {\n    debug('No callback for reply');\n  }\n}\n\nfunction subscribe_unsubscribe(self, reply, type) {\n  // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n  // The pub sub commands return each argument in a separate return value and have to be handled that way\n  var command_obj = self.command_queue.get(0);\n  var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n  var channel = buffer || reply[1] === null ? reply[1] : reply[1].toString();\n  var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n\n  debug(type, channel); // Emit first, then return the callback\n\n  if (channel !== null) {\n    // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n    self.emit(type, channel, count);\n\n    if (type === 'subscribe' || type === 'psubscribe') {\n      self.subscription_set[type + '_' + channel] = channel;\n    } else {\n      type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n\n      delete self.subscription_set[type + '_' + channel];\n    }\n  }\n\n  if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n    if (count === 0) {\n      // unsubscribed from all channels\n      var running_command;\n      var i = 1;\n      self.pub_sub_mode = 0; // Deactivating pub sub mode\n      // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n\n      while (running_command = self.command_queue.get(i)) {\n        if (SUBSCRIBE_COMMANDS[running_command.command]) {\n          self.pub_sub_mode = i; // Entering pub sub mode again\n\n          break;\n        }\n\n        i++;\n      }\n    }\n\n    self.command_queue.shift();\n\n    if (typeof command_obj.callback === 'function') {\n      // TODO: The current return value is pretty useless.\n      // Evaluate to change this in v.4 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n      command_obj.callback(null, channel);\n    }\n\n    self.sub_commands_left = 0;\n  } else {\n    if (self.sub_commands_left !== 0) {\n      self.sub_commands_left--;\n    } else {\n      self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n    }\n  }\n}\n\nfunction return_pub_sub(self, reply) {\n  var type = reply[0].toString();\n\n  if (type === 'message') {\n    // channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n      self.emit('message', reply[1].toString(), reply[2].toString());\n      self.emit('message_buffer', reply[1], reply[2]);\n      self.emit('messageBuffer', reply[1], reply[2]);\n    } else {\n      self.emit('message', reply[1], reply[2]);\n    }\n  } else if (type === 'pmessage') {\n    // pattern, channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n      self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n      self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n      self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n    } else {\n      self.emit('pmessage', reply[1], reply[2], reply[3]);\n    }\n  } else {\n    subscribe_unsubscribe(self, reply, type);\n  }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n  if (this.monitoring) {\n    var replyStr;\n\n    if (this.buffers && Buffer.isBuffer(reply)) {\n      replyStr = reply.toString();\n    } else {\n      replyStr = reply;\n    } // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n\n\n    if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n      var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n      var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n        return elem.replace(/\\\\\"/g, '\"');\n      });\n      this.emit('monitor', timestamp, args, replyStr);\n      return;\n    }\n  }\n\n  if (this.pub_sub_mode === 0) {\n    normal_reply(this, reply);\n  } else if (this.pub_sub_mode !== 1) {\n    this.pub_sub_mode--;\n    normal_reply(this, reply);\n  } else if (!(reply instanceof Array) || reply.length <= 2) {\n    // Only PING and QUIT are allowed in this context besides the pub sub commands\n    // Ping replies with ['pong', null|value] and quit with 'OK'\n    normal_reply(this, reply);\n  } else {\n    return_pub_sub(this, reply);\n  }\n};\n\nfunction handle_offline_command(self, command_obj) {\n  var command = command_obj.command;\n  var err, msg;\n\n  if (self.closing || !self.enable_offline_queue) {\n    command = command.toUpperCase();\n\n    if (!self.closing) {\n      if (self.stream.writable) {\n        msg = 'The connection is not yet established and the offline queue is deactivated.';\n      } else {\n        msg = 'Stream not writeable.';\n      }\n    } else {\n      msg = 'The connection is already closed.';\n    }\n\n    err = new errorClasses.AbortError({\n      message: command + \" can't be processed. \" + msg,\n      code: 'NR_CLOSED',\n      command: command\n    });\n\n    if (command_obj.args.length) {\n      err.args = command_obj.args;\n    }\n\n    utils.reply_in_order(self, command_obj.callback, err);\n  } else {\n    debug('Queueing ' + command + ' for next server connection.');\n    self.offline_queue.push(command_obj);\n  }\n\n  self.should_buffer = true;\n} // Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\n\n\nRedisClient.prototype.internal_send_command = function (command_obj) {\n  var arg, prefix_keys;\n  var i = 0;\n  var command_str = '';\n  var args = command_obj.args;\n  var command = command_obj.command;\n  var len = args.length;\n  var big_data = false;\n  var args_copy = new Array(len);\n\n  if (process.domain && command_obj.callback) {\n    command_obj.callback = process.domain.bind(command_obj.callback);\n  }\n\n  if (this.ready === false || this.stream.writable === false) {\n    // Handle offline commands right away\n    handle_offline_command(this, command_obj);\n    return false; // Indicate buffering\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (typeof args[i] === 'string') {\n      // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n      if (args[i].length > 30000) {\n        big_data = true;\n        args_copy[i] = Buffer.from(args[i], 'utf8');\n      } else {\n        args_copy[i] = args[i];\n      }\n    } else if (typeof args[i] === 'object') {\n      // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n      if (args[i] instanceof Date) {\n        // Accept dates as valid input\n        args_copy[i] = args[i].toString();\n      } else if (Buffer.isBuffer(args[i])) {\n        args_copy[i] = args[i];\n        command_obj.buffer_args = true;\n        big_data = true;\n      } else {\n        var invalidArgError = new Error('node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type.\\n' + 'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.');\n        invalidArgError.command = command_obj.command.toUpperCase();\n\n        if (command_obj.args && command_obj.args.length) {\n          invalidArgError.args = command_obj.args;\n        }\n\n        if (command_obj.callback) {\n          command_obj.callback(invalidArgError);\n          return false;\n        }\n\n        throw invalidArgError;\n      }\n    } else if (typeof args[i] === 'undefined') {\n      var undefinedArgError = new Error('node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type of \"undefined\".\\n' + 'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.');\n      undefinedArgError.command = command_obj.command.toUpperCase();\n\n      if (command_obj.args && command_obj.args.length) {\n        undefinedArgError.args = command_obj.args;\n      } // there is always a callback in this scenario\n\n\n      command_obj.callback(undefinedArgError);\n      return false;\n    } else {\n      // Seems like numbers are converted fast using string concatenation\n      args_copy[i] = '' + args[i];\n    }\n  }\n\n  if (this.options.prefix) {\n    prefix_keys = commands.getKeyIndexes(command, args_copy);\n\n    for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n      args_copy[i] = this.options.prefix + args_copy[i];\n    }\n  }\n\n  if (this.options.rename_commands && this.options.rename_commands[command]) {\n    command = this.options.rename_commands[command];\n  } // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n  // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n\n\n  command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n  if (big_data === false) {\n    // Build up a string and send entire command in one write\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n      command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n    }\n\n    debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n    this.write(command_str);\n  } else {\n    debug('Send command (' + command_str + ') has Buffer arguments');\n    this.fire_strings = false;\n    this.write(command_str);\n\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n\n      if (typeof arg === 'string') {\n        this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n      } else {\n        // buffer\n        this.write('$' + arg.length + '\\r\\n');\n        this.write(arg);\n        this.write('\\r\\n');\n      }\n\n      debug('send_command: buffer send ' + arg.length + ' bytes');\n    }\n  }\n\n  if (command_obj.call_on_write) {\n    command_obj.call_on_write();\n  } // Handle `CLIENT REPLY ON|OFF|SKIP`\n  // This has to be checked after call_on_write\n\n  /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n\n\n  if (this.reply === 'ON') {\n    this.command_queue.push(command_obj);\n  } else {\n    // Do not expect a reply\n    // Does this work in combination with the pub sub mode?\n    if (command_obj.callback) {\n      utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n    }\n\n    if (this.reply === 'SKIP') {\n      this.reply = 'SKIP_ONE_MORE';\n    } else if (this.reply === 'SKIP_ONE_MORE') {\n      this.reply = 'ON';\n    }\n  }\n\n  return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n  var str = '';\n\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n    if (str.length + command.length > 4 * 1024 * 1024) {\n      this.should_buffer = !this.stream.write(str);\n      str = '';\n    }\n\n    str += command;\n  }\n\n  if (str !== '') {\n    this.should_buffer = !this.stream.write(str);\n  }\n};\n\nRedisClient.prototype.write_buffers = function () {\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    this.should_buffer = !this.stream.write(command);\n  }\n};\n\nRedisClient.prototype.write = function (data) {\n  if (this.pipeline === false) {\n    this.should_buffer = !this.stream.write(data);\n    return;\n  }\n\n  this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n  get: function get() {\n    return this.debug_mode;\n  },\n  set: function set(val) {\n    this.debug_mode = val;\n  }\n}); // Don't officially expose the command_queue directly but only the length as read only variable\n\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n  get: function get() {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n  get: function get() {\n    return this.offline_queue.length;\n  }\n}); // Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\n\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n  get: function get() {\n    return this.retry_delay;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n  get: function get() {\n    return this.retry_backoff;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n  get: function get() {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n  get: function get() {\n    return this.offline_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n  get: function get() {\n    return this.should_buffer;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n  get: function get() {\n    return this.connection_id;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n  get: function get() {\n    return this.server_info;\n  }\n});\n\nexports.createClient = function () {\n  return new RedisClient(unifyOptions.apply(null, arguments));\n};\n\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = RedisErrors.RedisError;\nexports.ParserError = RedisErrors.ParserError;\nexports.ReplyError = RedisErrors.ReplyError;\nexports.AggregateError = errorClasses.AggregateError; // Add all redis commands / node_redis api to the client\n\nrequire('./lib/individualCommands');\n\nrequire('./lib/extendedApi'); //enables adding new commands (for modules and new commands)\n\n\nexports.addCommand = exports.add_command = require('./lib/commands');","map":{"version":3,"sources":["/home/daniel/Projects/critter-catcher/node_modules/redis/index.js"],"names":["net","require","tls","util","utils","Command","Queue","errorClasses","EventEmitter","Parser","RedisErrors","commands","debug","unifyOptions","SUBSCRIBE_COMMANDS","subscribe","unsubscribe","psubscribe","punsubscribe","noop","handle_detect_buffers_reply","reply","command","buffer_args","message_buffers","reply_to_strings","reply_to_object","exports","debug_mode","test","process","env","NODE_DEBUG","RedisClient","options","stream","clone","call","cnx_options","self","tls_option","address","path","port","host","family","isIP","connection_options","connection_id","connected","ready","socket_keepalive","undefined","socket_initial_delay","rename_commands","toLowerCase","return_buffers","detect_buffers","warn","handle_reply","should_buffer","command_queue","offline_queue","pipeline_queue","connect_timeout","enable_offline_queue","initialize_retry_vars","pub_sub_mode","subscription_set","monitoring","closing","server_info","auth_pass","password","selected_db","db","fire_strings","pipeline","sub_commands_left","times_connected","buffers","create_stream","on","event","reply_parser","optionReturnBuffers","inherits","create_parser","returnReply","data","return_reply","returnError","err","return_error","returnFatalError","message","flush_and_error","code","error","queues","emit","returnBuffers","stringNumbers","string_numbers","prototype","removeAllListeners","destroy","connect","createConnection","setTimeout","retry_totaltime","connection_gone","connect_event","once","on_connect","buffer_from_socket","execute","on_error","hadError","drain","setNoDelay","auth","cork","uncork","retry_timer","retry_delay","retry_backoff","attempts","msg","nextTick","listeners","length","console","error_attributes","aggregated_errors","queue_names","i","replace","command_obj","shift","AbortError","stack","toUpperCase","args","origin","callback","push","AggregateError","errors","retry_strategy","emitted_end","setKeepAlive","no_ready_check","on_ready","ready_check","write_strings","write_buffers","internal_send_command","callback_count","Object","keys","disable_resubscribing","key","slice","indexOf","send_offline_queue","on_info_cmd","res","loading","master_link_status","loading_eta_seconds","retry_time","info","retry_connection","reconnect_params","delay","attempt","camel_case","totalRetryTime","timesConnected","total_retry_time","Math","round","why","retry_params","Error","errorMessage","retryError","end","retry_unfulfilled_commands","unshift","apply","toArray","clear","match","err_code","callback_or_emit","normal_reply","subscribe_unsubscribe","type","get","buffer","channel","toString","count","running_command","return_pub_sub","replyStr","Buffer","isBuffer","monitor_regex","timestamp","split","map","elem","Array","handle_offline_command","writable","reply_in_order","arg","prefix_keys","command_str","len","big_data","args_copy","domain","bind","from","Date","invalidArgError","undefinedArgError","prefix","getKeyIndexes","pop","byteLength","write","call_on_write","str","defineProperty","set","val","createClient","arguments","print","Multi","RedisError","ParserError","ReplyError","addCommand","add_command"],"mappings":"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","sourcesContent":["'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar utils = require('./lib/utils');\nvar Command = require('./lib/command');\nvar Queue = require('denque');\nvar errorClasses = require('./lib/customErrors');\nvar EventEmitter = require('events');\nvar Parser = require('redis-parser');\nvar RedisErrors = require('redis-errors');\nvar commands = require('redis-commands');\nvar debug = require('./lib/debug');\nvar unifyOptions = require('./lib/createClient');\nvar SUBSCRIBE_COMMANDS = {\n    subscribe: true,\n    unsubscribe: true,\n    psubscribe: true,\n    punsubscribe: true\n};\n\nfunction noop () {}\n\nfunction handle_detect_buffers_reply (reply, command, buffer_args) {\n    if (buffer_args === false || this.message_buffers) {\n        // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n        // If this command did not use Buffer arguments, then convert the reply to Strings here.\n        reply = utils.reply_to_strings(reply);\n    }\n\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG);\n\n// Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\nfunction RedisClient (options, stream) {\n    // Copy the options so they are not mutated\n    options = utils.clone(options);\n    EventEmitter.call(this);\n    var cnx_options = {};\n    var self = this;\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    for (var tls_option in options.tls) {\n        cnx_options[tls_option] = options.tls[tls_option];\n        // Copy the tls options into the general options to make sure the address is set right\n        if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n            options[tls_option] = options.tls[tls_option];\n        }\n    }\n    if (stream) {\n        // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n        // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n        options.stream = stream;\n        this.address = '\"Private stream\"';\n    } else if (options.path) {\n        cnx_options.path = options.path;\n        this.address = options.path;\n    } else {\n        cnx_options.port = +options.port || 6379;\n        cnx_options.host = options.host || '127.0.0.1';\n        cnx_options.family = (!options.family && net.isIP(cnx_options.host)) || (options.family === 'IPv6' ? 6 : 4);\n        this.address = cnx_options.host + ':' + cnx_options.port;\n    }\n\n    this.connection_options = cnx_options;\n    this.connection_id = RedisClient.connection_id++;\n    this.connected = false;\n    this.ready = false;\n    if (options.socket_keepalive === undefined) {\n        options.socket_keepalive = true;\n    }\n    if (options.socket_initial_delay === undefined) {\n        options.socket_initial_delay = 0;\n        // set default to 0, which is aligned to https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay\n    }\n    for (var command in options.rename_commands) {\n        options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n    }\n    options.return_buffers = !!options.return_buffers;\n    options.detect_buffers = !!options.detect_buffers;\n    // Override the detect_buffers setting if return_buffers is active and print a warning\n    if (options.return_buffers && options.detect_buffers) {\n        self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n        options.detect_buffers = false;\n    }\n    if (options.detect_buffers) {\n        // We only need to look at the arguments if we do not know what we have to return\n        this.handle_reply = handle_detect_buffers_reply;\n    }\n    this.should_buffer = false;\n    this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n    this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n    this.pipeline_queue = new Queue(); // Holds all pipelined commands\n    // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n    // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n    this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n    this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n    this.initialize_retry_vars();\n    this.pub_sub_mode = 0;\n    this.subscription_set = {};\n    this.monitoring = false;\n    this.message_buffers = false;\n    this.closing = false;\n    this.server_info = {};\n    this.auth_pass = options.auth_pass || options.password;\n    this.selected_db = options.db; // Save the selected db here, used when reconnecting\n    this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n    this.pipeline = false;\n    this.sub_commands_left = 0;\n    this.times_connected = 0;\n    this.buffers = options.return_buffers || options.detect_buffers;\n    this.options = options;\n    this.reply = 'ON'; // Returning replies is the default\n    this.create_stream();\n    // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n    this.on('newListener', function (event) {\n        if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n            this.reply_parser.optionReturnBuffers = true;\n            this.message_buffers = true;\n            this.handle_reply = handle_detect_buffers_reply;\n        }\n    });\n}\nutil.inherits(RedisClient, EventEmitter);\n\nRedisClient.connection_id = 0;\n\nfunction create_parser (self) {\n    return new Parser({\n        returnReply: function (data) {\n            self.return_reply(data);\n        },\n        returnError: function (err) {\n            // Return a ReplyError to indicate Redis returned an error\n            self.return_error(err);\n        },\n        returnFatalError: function (err) {\n            // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n            // Note: the execution order is important. First flush and emit, then create the stream\n            err.message += '. Please report this.';\n            self.ready = false;\n            self.flush_and_error({\n                message: 'Fatal error encountered. Command aborted.',\n                code: 'NR_FATAL'\n            }, {\n                error: err,\n                queues: ['command_queue']\n            });\n            self.emit('error', err);\n            self.create_stream();\n        },\n        returnBuffers: self.buffers || self.message_buffers,\n        stringNumbers: self.options.string_numbers || false\n    });\n}\n\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\nRedisClient.prototype.create_stream = function () {\n    var self = this;\n\n    // Init parser\n    this.reply_parser = create_parser(this);\n\n    if (this.options.stream) {\n        // Only add the listeners once in case of a reconnect try (that won't work)\n        if (this.stream) {\n            return;\n        }\n        this.stream = this.options.stream;\n    } else {\n        // On a reconnect destroy the former stream and retry\n        if (this.stream) {\n            this.stream.removeAllListeners();\n            this.stream.destroy();\n        }\n\n        /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n        if (this.options.tls) {\n            this.stream = tls.connect(this.connection_options);\n        } else {\n            this.stream = net.createConnection(this.connection_options);\n        }\n    }\n\n    if (this.options.connect_timeout) {\n        this.stream.setTimeout(this.connect_timeout, function () {\n            // Note: This is only tested if a internet connection is established\n            self.retry_totaltime = self.connect_timeout;\n            self.connection_gone('timeout');\n        });\n    }\n\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n    this.stream.once(connect_event, function () {\n        this.removeAllListeners('timeout');\n        self.times_connected++;\n        self.on_connect();\n    });\n\n    this.stream.on('data', function (buffer_from_socket) {\n        // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n        debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n        self.reply_parser.execute(buffer_from_socket);\n    });\n\n    this.stream.on('error', function (err) {\n        self.on_error(err);\n    });\n\n    this.stream.once('close', function (hadError) {\n        self.connection_gone('close');\n    });\n\n    this.stream.once('end', function () {\n        self.connection_gone('end');\n    });\n\n    this.stream.on('drain', function () {\n        self.drain();\n    });\n\n    this.stream.setNoDelay();\n\n    // Fire the command before redis is connected to be sure it's the first fired command\n    if (this.auth_pass !== undefined) {\n        this.ready = true;\n        // Fail silently as we might not be able to connect\n        this.auth(this.auth_pass, function (err) {\n            if (err && err.code !== 'UNCERTAIN_STATE') {\n                self.emit('error', err);\n            }\n        });\n        this.ready = false;\n    }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n    this.retry_timer = null;\n    this.retry_totaltime = 0;\n    this.retry_delay = 200;\n    this.retry_backoff = 1.7;\n    this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n    var self = this;\n    // Warn on the next tick. Otherwise no event listener can be added\n    // for warnings that are emitted in the redis client constructor\n    process.nextTick(function () {\n        if (self.listeners('warning').length !== 0) {\n            self.emit('warning', msg);\n        } else {\n            console.warn('node_redis:', msg);\n        }\n    });\n};\n\n// Flush provided queues, erroring any items with a callback first\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n    options = options || {};\n    var aggregated_errors = [];\n    var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n    for (var i = 0; i < queue_names.length; i++) {\n        // If the command was fired it might have been processed so far\n        if (queue_names[i] === 'command_queue') {\n            error_attributes.message += ' It might have been processed.';\n        } else { // As the command_queue is flushed first, remove this for the offline queue\n            error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n        }\n        // Don't flush everything from the queue\n        for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n            var err = new errorClasses.AbortError(error_attributes);\n            if (command_obj.error) {\n                err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n            }\n            err.command = command_obj.command.toUpperCase();\n            if (command_obj.args && command_obj.args.length) {\n                err.args = command_obj.args;\n            }\n            if (options.error) {\n                err.origin = options.error;\n            }\n            if (typeof command_obj.callback === 'function') {\n                command_obj.callback(err);\n            } else {\n                aggregated_errors.push(err);\n            }\n        }\n    }\n    // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n    if (exports.debug_mode && aggregated_errors.length) {\n        var error;\n        if (aggregated_errors.length === 1) {\n            error = aggregated_errors[0];\n        } else {\n            error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n            error = new errorClasses.AggregateError(error_attributes);\n            error.errors = aggregated_errors;\n        }\n        this.emit('error', error);\n    }\n};\n\nRedisClient.prototype.on_error = function (err) {\n    if (this.closing) {\n        return;\n    }\n\n    err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n    debug(err.message);\n    this.connected = false;\n    this.ready = false;\n\n    // Only emit the error if the retry_strategy option is not set\n    if (!this.options.retry_strategy) {\n        this.emit('error', err);\n    }\n    // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n    // then we should try to reconnect.\n    this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n    debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n\n    this.connected = true;\n    this.ready = false;\n    this.emitted_end = false;\n    this.stream.setKeepAlive(this.options.socket_keepalive, this.options.socket_initial_delay);\n    this.stream.setTimeout(0);\n\n    this.emit('connect');\n    this.initialize_retry_vars();\n\n    if (this.options.no_ready_check) {\n        this.on_ready();\n    } else {\n        this.ready_check();\n    }\n};\n\nRedisClient.prototype.on_ready = function () {\n    var self = this;\n\n    debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n    this.ready = true;\n\n    this.cork = function () {\n        self.pipeline = true;\n        if (self.stream.cork) {\n            self.stream.cork();\n        }\n    };\n    this.uncork = function () {\n        if (self.fire_strings) {\n            self.write_strings();\n        } else {\n            self.write_buffers();\n        }\n        self.pipeline = false;\n        self.fire_strings = true;\n        if (self.stream.uncork) {\n            // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n            self.stream.uncork();\n        }\n    };\n\n    // Restore modal commands from previous connection. The order of the commands is important\n    if (this.selected_db !== undefined) {\n        this.internal_send_command(new Command('select', [this.selected_db]));\n    }\n    if (this.monitoring) { // Monitor has to be fired before pub sub commands\n        this.internal_send_command(new Command('monitor', []));\n    }\n    var callback_count = Object.keys(this.subscription_set).length;\n    if (!this.options.disable_resubscribing && callback_count) {\n        // only emit 'ready' when all subscriptions were made again\n        // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n        // We know we are ready as soon as all commands were fired\n        var callback = function () {\n            callback_count--;\n            if (callback_count === 0) {\n                self.emit('ready');\n            }\n        };\n        debug('Sending pub/sub on_ready commands');\n        for (var key in this.subscription_set) {\n            var command = key.slice(0, key.indexOf('_'));\n            var args = this.subscription_set[key];\n            this[command]([args], callback);\n        }\n        this.send_offline_queue();\n        return;\n    }\n    this.send_offline_queue();\n    this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n    if (err) {\n        if (err.message === \"ERR unknown command 'info'\") {\n            this.on_ready();\n            return;\n        }\n        err.message = 'Ready check failed: ' + err.message;\n        this.emit('error', err);\n        return;\n    }\n\n    /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n    if (!res) {\n        debug('The info command returned without any data.');\n        this.on_ready();\n        return;\n    }\n\n    if (!this.server_info.loading || this.server_info.loading === '0') {\n        // If the master_link_status exists but the link is not up, try again after 50 ms\n        if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n            this.server_info.loading_eta_seconds = 0.05;\n        } else {\n            // Eta loading should change\n            debug('Redis server ready.');\n            this.on_ready();\n            return;\n        }\n    }\n\n    var retry_time = +this.server_info.loading_eta_seconds * 1000;\n    if (retry_time > 1000) {\n        retry_time = 1000;\n    }\n    debug('Redis server still loading, trying again in ' + retry_time);\n    setTimeout(function (self) {\n        self.ready_check();\n    }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n    var self = this;\n    debug('Checking server ready state...');\n    // Always fire this info command as first command even if other commands are already queued up\n    this.ready = true;\n    this.info(function (err, res) {\n        self.on_info_cmd(err, res);\n    });\n    this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n    for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n        debug('Sending offline command: ' + command_obj.command);\n        this.internal_send_command(command_obj);\n    }\n    this.drain();\n};\n\nvar retry_connection = function (self, error) {\n    debug('Retrying connection...');\n\n    var reconnect_params = {\n        delay: self.retry_delay,\n        attempt: self.attempts,\n        error: error\n    };\n    if (self.options.camel_case) {\n        reconnect_params.totalRetryTime = self.retry_totaltime;\n        reconnect_params.timesConnected = self.times_connected;\n    } else {\n        reconnect_params.total_retry_time = self.retry_totaltime;\n        reconnect_params.times_connected = self.times_connected;\n    }\n    self.emit('reconnecting', reconnect_params);\n\n    self.retry_totaltime += self.retry_delay;\n    self.attempts += 1;\n    self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n    self.create_stream();\n    self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n    // If a retry is already in progress, just let that happen\n    if (this.retry_timer) {\n        return;\n    }\n    error = error || null;\n\n    debug('Redis connection is gone from ' + why + ' event.');\n    this.connected = false;\n    this.ready = false;\n    // Deactivate cork to work with the offline queue\n    this.cork = noop;\n    this.uncork = noop;\n    this.pipeline = false;\n    this.pub_sub_mode = 0;\n\n    // since we are collapsing end and close, users don't expect to be called twice\n    if (!this.emitted_end) {\n        this.emit('end');\n        this.emitted_end = true;\n    }\n\n    // If this is a requested shutdown, then don't retry\n    if (this.closing) {\n        debug('Connection ended by quit / end command, not retrying.');\n        this.flush_and_error({\n            message: 'Stream connection ended and command aborted.',\n            code: 'NR_CLOSED'\n        }, {\n            error: error\n        });\n        return;\n    }\n\n    if (typeof this.options.retry_strategy === 'function') {\n        var retry_params = {\n            attempt: this.attempts,\n            error: error\n        };\n        if (this.options.camel_case) {\n            retry_params.totalRetryTime = this.retry_totaltime;\n            retry_params.timesConnected = this.times_connected;\n        } else {\n            retry_params.total_retry_time = this.retry_totaltime;\n            retry_params.times_connected = this.times_connected;\n        }\n        this.retry_delay = this.options.retry_strategy(retry_params);\n        if (typeof this.retry_delay !== 'number') {\n            // Pass individual error through\n            if (this.retry_delay instanceof Error) {\n                error = this.retry_delay;\n            }\n\n            var errorMessage = 'Redis connection in broken state: retry aborted.';\n\n            this.flush_and_error({\n                message: errorMessage,\n                code: 'CONNECTION_BROKEN',\n            }, {\n                error: error\n            });\n            var retryError = new Error(errorMessage);\n            retryError.code = 'CONNECTION_BROKEN';\n            if (error) {\n                retryError.origin = error;\n            }\n            this.end(false);\n            this.emit('error', retryError);\n            return;\n        }\n    }\n\n    if (this.retry_totaltime >= this.connect_timeout) {\n        var message = 'Redis connection in broken state: connection timeout exceeded.';\n        this.flush_and_error({\n            message: message,\n            code: 'CONNECTION_BROKEN',\n        }, {\n            error: error\n        });\n        var err = new Error(message);\n        err.code = 'CONNECTION_BROKEN';\n        if (error) {\n            err.origin = error;\n        }\n        this.end(false);\n        this.emit('error', err);\n        return;\n    }\n\n    // Retry commands after a reconnect instead of throwing an error. Use this with caution\n    if (this.options.retry_unfulfilled_commands) {\n        this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n        this.command_queue.clear();\n    } else if (this.command_queue.length !== 0) {\n        this.flush_and_error({\n            message: 'Redis connection lost and command aborted.',\n            code: 'UNCERTAIN_STATE'\n        }, {\n            error: error,\n            queues: ['command_queue']\n        });\n    }\n\n    if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n        // Do not exceed the maximum\n        this.retry_delay = this.connect_timeout - this.retry_totaltime;\n    }\n\n    debug('Retry connection in ' + this.retry_delay + ' ms');\n    this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n    var command_obj = this.command_queue.shift();\n    if (command_obj.error) {\n        err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n    }\n    err.command = command_obj.command.toUpperCase();\n    if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n    }\n\n    // Count down pub sub mode if in entering modus\n    if (this.pub_sub_mode > 1) {\n        this.pub_sub_mode--;\n    }\n\n    var match = err.message.match(utils.err_code);\n    // LUA script could return user errors that don't behave like all other errors!\n    if (match) {\n        err.code = match[1];\n    }\n\n    utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n    this.should_buffer = false;\n};\n\nfunction normal_reply (self, reply) {\n    var command_obj = self.command_queue.shift();\n    if (typeof command_obj.callback === 'function') {\n        if (command_obj.command !== 'exec') {\n            reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n        }\n        command_obj.callback(null, reply);\n    } else {\n        debug('No callback for reply');\n    }\n}\n\nfunction subscribe_unsubscribe (self, reply, type) {\n    // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n    // The pub sub commands return each argument in a separate return value and have to be handled that way\n    var command_obj = self.command_queue.get(0);\n    var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n    var channel = (buffer || reply[1] === null) ? reply[1] : reply[1].toString();\n    var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n    debug(type, channel);\n\n    // Emit first, then return the callback\n    if (channel !== null) { // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n        self.emit(type, channel, count);\n        if (type === 'subscribe' || type === 'psubscribe') {\n            self.subscription_set[type + '_' + channel] = channel;\n        } else {\n            type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n            delete self.subscription_set[type + '_' + channel];\n        }\n    }\n\n    if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n        if (count === 0) { // unsubscribed from all channels\n            var running_command;\n            var i = 1;\n            self.pub_sub_mode = 0; // Deactivating pub sub mode\n            // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n            while (running_command = self.command_queue.get(i)) {\n                if (SUBSCRIBE_COMMANDS[running_command.command]) {\n                    self.pub_sub_mode = i; // Entering pub sub mode again\n                    break;\n                }\n                i++;\n            }\n        }\n        self.command_queue.shift();\n        if (typeof command_obj.callback === 'function') {\n            // TODO: The current return value is pretty useless.\n            // Evaluate to change this in v.4 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n            command_obj.callback(null, channel);\n        }\n        self.sub_commands_left = 0;\n    } else {\n        if (self.sub_commands_left !== 0) {\n            self.sub_commands_left--;\n        } else {\n            self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n        }\n    }\n}\n\nfunction return_pub_sub (self, reply) {\n    var type = reply[0].toString();\n    if (type === 'message') { // channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n            self.emit('message', reply[1].toString(), reply[2].toString());\n            self.emit('message_buffer', reply[1], reply[2]);\n            self.emit('messageBuffer', reply[1], reply[2]);\n        } else {\n            self.emit('message', reply[1], reply[2]);\n        }\n    } else if (type === 'pmessage') { // pattern, channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n            self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n            self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n            self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n        } else {\n            self.emit('pmessage', reply[1], reply[2], reply[3]);\n        }\n    } else {\n        subscribe_unsubscribe(self, reply, type);\n    }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n    if (this.monitoring) {\n        var replyStr;\n        if (this.buffers && Buffer.isBuffer(reply)) {\n            replyStr = reply.toString();\n        } else {\n            replyStr = reply;\n        }\n        // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n        if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n            var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n            var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n                return elem.replace(/\\\\\"/g, '\"');\n            });\n            this.emit('monitor', timestamp, args, replyStr);\n            return;\n        }\n    }\n    if (this.pub_sub_mode === 0) {\n        normal_reply(this, reply);\n    } else if (this.pub_sub_mode !== 1) {\n        this.pub_sub_mode--;\n        normal_reply(this, reply);\n    } else if (!(reply instanceof Array) || reply.length <= 2) {\n        // Only PING and QUIT are allowed in this context besides the pub sub commands\n        // Ping replies with ['pong', null|value] and quit with 'OK'\n        normal_reply(this, reply);\n    } else {\n        return_pub_sub(this, reply);\n    }\n};\n\nfunction handle_offline_command (self, command_obj) {\n    var command = command_obj.command;\n    var err, msg;\n    if (self.closing || !self.enable_offline_queue) {\n        command = command.toUpperCase();\n        if (!self.closing) {\n            if (self.stream.writable) {\n                msg = 'The connection is not yet established and the offline queue is deactivated.';\n            } else {\n                msg = 'Stream not writeable.';\n            }\n        } else {\n            msg = 'The connection is already closed.';\n        }\n        err = new errorClasses.AbortError({\n            message: command + \" can't be processed. \" + msg,\n            code: 'NR_CLOSED',\n            command: command\n        });\n        if (command_obj.args.length) {\n            err.args = command_obj.args;\n        }\n        utils.reply_in_order(self, command_obj.callback, err);\n    } else {\n        debug('Queueing ' + command + ' for next server connection.');\n        self.offline_queue.push(command_obj);\n    }\n    self.should_buffer = true;\n}\n\n// Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\nRedisClient.prototype.internal_send_command = function (command_obj) {\n    var arg, prefix_keys;\n    var i = 0;\n    var command_str = '';\n    var args = command_obj.args;\n    var command = command_obj.command;\n    var len = args.length;\n    var big_data = false;\n    var args_copy = new Array(len);\n\n    if (process.domain && command_obj.callback) {\n        command_obj.callback = process.domain.bind(command_obj.callback);\n    }\n\n    if (this.ready === false || this.stream.writable === false) {\n        // Handle offline commands right away\n        handle_offline_command(this, command_obj);\n        return false; // Indicate buffering\n    }\n\n    for (i = 0; i < len; i += 1) {\n        if (typeof args[i] === 'string') {\n            // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n            if (args[i].length > 30000) {\n                big_data = true;\n                args_copy[i] = Buffer.from(args[i], 'utf8');\n            } else {\n                args_copy[i] = args[i];\n            }\n        } else if (typeof args[i] === 'object') { // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n            if (args[i] instanceof Date) { // Accept dates as valid input\n                args_copy[i] = args[i].toString();\n            } else if (Buffer.isBuffer(args[i])) {\n                args_copy[i] = args[i];\n                command_obj.buffer_args = true;\n                big_data = true;\n            } else {\n                var invalidArgError = new Error(\n                    'node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type.\\n' +\n                    'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.'\n                );\n                invalidArgError.command = command_obj.command.toUpperCase();\n                if (command_obj.args && command_obj.args.length) {\n                    invalidArgError.args = command_obj.args;\n                }\n                if (command_obj.callback) {\n                    command_obj.callback(invalidArgError);\n                    return false;\n                }\n                throw invalidArgError;\n            }\n        } else if (typeof args[i] === 'undefined') {\n            var undefinedArgError = new Error(\n                'node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type of \"undefined\".\\n' +\n                'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.'\n            );\n            undefinedArgError.command = command_obj.command.toUpperCase();\n            if (command_obj.args && command_obj.args.length) {\n                undefinedArgError.args = command_obj.args;\n            }\n            // there is always a callback in this scenario\n            command_obj.callback(undefinedArgError);\n            return false;\n        } else {\n            // Seems like numbers are converted fast using string concatenation\n            args_copy[i] = '' + args[i];\n        }\n    }\n\n    if (this.options.prefix) {\n        prefix_keys = commands.getKeyIndexes(command, args_copy);\n        for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n            args_copy[i] = this.options.prefix + args_copy[i];\n        }\n    }\n    if (this.options.rename_commands && this.options.rename_commands[command]) {\n        command = this.options.rename_commands[command];\n    }\n    // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n    command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n    if (big_data === false) { // Build up a string and send entire command in one write\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n        }\n        debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n        this.write(command_str);\n    } else {\n        debug('Send command (' + command_str + ') has Buffer arguments');\n        this.fire_strings = false;\n        this.write(command_str);\n\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            if (typeof arg === 'string') {\n                this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n            } else { // buffer\n                this.write('$' + arg.length + '\\r\\n');\n                this.write(arg);\n                this.write('\\r\\n');\n            }\n            debug('send_command: buffer send ' + arg.length + ' bytes');\n        }\n    }\n    if (command_obj.call_on_write) {\n        command_obj.call_on_write();\n    }\n    // Handle `CLIENT REPLY ON|OFF|SKIP`\n    // This has to be checked after call_on_write\n    /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n    if (this.reply === 'ON') {\n        this.command_queue.push(command_obj);\n    } else {\n        // Do not expect a reply\n        // Does this work in combination with the pub sub mode?\n        if (command_obj.callback) {\n            utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n        }\n        if (this.reply === 'SKIP') {\n            this.reply = 'SKIP_ONE_MORE';\n        } else if (this.reply === 'SKIP_ONE_MORE') {\n            this.reply = 'ON';\n        }\n    }\n    return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n    var str = '';\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n        if (str.length + command.length > 4 * 1024 * 1024) {\n            this.should_buffer = !this.stream.write(str);\n            str = '';\n        }\n        str += command;\n    }\n    if (str !== '') {\n        this.should_buffer = !this.stream.write(str);\n    }\n};\n\nRedisClient.prototype.write_buffers = function () {\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        this.should_buffer = !this.stream.write(command);\n    }\n};\n\nRedisClient.prototype.write = function (data) {\n    if (this.pipeline === false) {\n        this.should_buffer = !this.stream.write(data);\n        return;\n    }\n    this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n    get: function () {\n        return this.debug_mode;\n    },\n    set: function (val) {\n        this.debug_mode = val;\n    }\n});\n\n// Don't officially expose the command_queue directly but only the length as read only variable\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\n// Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n    get: function () {\n        return this.retry_delay;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n    get: function () {\n        return this.retry_backoff;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n    get: function () {\n        return this.should_buffer;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n    get: function () {\n        return this.connection_id;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n    get: function () {\n        return this.server_info;\n    }\n});\n\nexports.createClient = function () {\n    return new RedisClient(unifyOptions.apply(null, arguments));\n};\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = RedisErrors.RedisError;\nexports.ParserError = RedisErrors.ParserError;\nexports.ReplyError = RedisErrors.ReplyError;\nexports.AggregateError = errorClasses.AggregateError;\n\n// Add all redis commands / node_redis api to the client\nrequire('./lib/individualCommands');\nrequire('./lib/extendedApi');\n\n//enables adding new commands (for modules and new commands)\nexports.addCommand = exports.add_command = require('./lib/commands');\n"]},"metadata":{},"sourceType":"script"}