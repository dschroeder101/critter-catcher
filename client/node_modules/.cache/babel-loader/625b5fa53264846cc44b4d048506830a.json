{"ast":null,"code":"'use strict';\n\nvar Queue = require('denque');\n\nvar utils = require('./utils');\n\nvar Command = require('./command');\n\nfunction Multi(client, args) {\n  this._client = client;\n  this.queue = new Queue();\n  var command, tmp_args;\n\n  if (args) {\n    // Either undefined or an array. Fail hard if it's not an array\n    for (var i = 0; i < args.length; i++) {\n      command = args[i][0];\n      tmp_args = args[i].slice(1);\n\n      if (Array.isArray(command)) {\n        this[command[0]].apply(this, command.slice(1).concat(tmp_args));\n      } else {\n        this[command].apply(this, tmp_args);\n      }\n    }\n  }\n}\n\nfunction pipeline_transaction_command(self, command_obj, index) {\n  // Queueing is done first, then the commands are executed\n  var tmp = command_obj.callback;\n\n  command_obj.callback = function (err, reply) {\n    // Ignore the multi command. This is applied by node_redis and the user does not benefit by it\n    if (err && index !== -1) {\n      if (tmp) {\n        tmp(err);\n      }\n\n      err.position = index;\n      self.errors.push(err);\n    } // Keep track of who wants buffer responses:\n    // By the time the callback is called the command_obj got the buffer_args attribute attached\n\n\n    self.wants_buffers[index] = command_obj.buffer_args;\n    command_obj.callback = tmp;\n  };\n\n  self._client.internal_send_command(command_obj);\n}\n\nMulti.prototype.exec_atomic = Multi.prototype.EXEC_ATOMIC = Multi.prototype.execAtomic = function exec_atomic(callback) {\n  if (this.queue.length < 2) {\n    return this.exec_batch(callback);\n  }\n\n  return this.exec(callback);\n};\n\nfunction multi_callback(self, err, replies) {\n  var i = 0,\n      command_obj;\n\n  if (err) {\n    err.errors = self.errors;\n\n    if (self.callback) {\n      self.callback(err); // Exclude connection errors so that those errors won't be emitted twice\n    } else if (err.code !== 'CONNECTION_BROKEN') {\n      self._client.emit('error', err);\n    }\n\n    return;\n  }\n\n  if (replies) {\n    while (command_obj = self.queue.shift()) {\n      if (replies[i] instanceof Error) {\n        var match = replies[i].message.match(utils.err_code); // LUA script could return user errors that don't behave like all other errors!\n\n        if (match) {\n          replies[i].code = match[1];\n        }\n\n        replies[i].command = command_obj.command.toUpperCase();\n\n        if (typeof command_obj.callback === 'function') {\n          command_obj.callback(replies[i]);\n        }\n      } else {\n        // If we asked for strings, even in detect_buffers mode, then return strings:\n        replies[i] = self._client.handle_reply(replies[i], command_obj.command, self.wants_buffers[i]);\n\n        if (typeof command_obj.callback === 'function') {\n          command_obj.callback(null, replies[i]);\n        }\n      }\n\n      i++;\n    }\n  }\n\n  if (self.callback) {\n    self.callback(null, replies);\n  }\n}\n\nMulti.prototype.exec_transaction = function exec_transaction(callback) {\n  if (this.monitoring || this._client.monitoring) {\n    var err = new RangeError('Using transaction with a client that is in monitor mode does not work due to faulty return values of Redis.');\n    err.command = 'EXEC';\n    err.code = 'EXECABORT';\n    return utils.reply_in_order(this._client, callback, err);\n  }\n\n  var self = this;\n  var len = self.queue.length;\n  self.errors = [];\n  self.callback = callback;\n\n  self._client.cork();\n\n  self.wants_buffers = new Array(len);\n  pipeline_transaction_command(self, new Command('multi', []), -1); // Drain queue, callback will catch 'QUEUED' or error\n\n  for (var index = 0; index < len; index++) {\n    // The commands may not be shifted off, since they are needed in the result handler\n    pipeline_transaction_command(self, self.queue.get(index), index);\n  }\n\n  self._client.internal_send_command(new Command('exec', [], function (err, replies) {\n    multi_callback(self, err, replies);\n  }));\n\n  self._client.uncork();\n\n  return !self._client.should_buffer;\n};\n\nfunction batch_callback(self, cb, i) {\n  return function batch_callback(err, res) {\n    if (err) {\n      self.results[i] = err; // Add the position to the error\n\n      self.results[i].position = i;\n    } else {\n      self.results[i] = res;\n    }\n\n    cb(err, res);\n  };\n}\n\nMulti.prototype.exec = Multi.prototype.EXEC = Multi.prototype.exec_batch = function exec_batch(callback) {\n  var self = this;\n  var len = self.queue.length;\n  var index = 0;\n  var command_obj;\n\n  if (len === 0) {\n    utils.reply_in_order(self._client, callback, null, []);\n    return !self._client.should_buffer;\n  }\n\n  self._client.cork();\n\n  if (!callback) {\n    while (command_obj = self.queue.shift()) {\n      self._client.internal_send_command(command_obj);\n    }\n\n    self._client.uncork();\n\n    return !self._client.should_buffer;\n  }\n\n  var callback_without_own_cb = function callback_without_own_cb(err, res) {\n    if (err) {\n      self.results.push(err); // Add the position to the error\n\n      var i = self.results.length - 1;\n      self.results[i].position = i;\n    } else {\n      self.results.push(res);\n    } // Do not emit an error here. Otherwise each error would result in one emit.\n    // The errors will be returned in the result anyway\n\n  };\n\n  var last_callback = function last_callback(cb) {\n    return function (err, res) {\n      cb(err, res);\n      callback(null, self.results);\n    };\n  };\n\n  self.results = [];\n\n  while (command_obj = self.queue.shift()) {\n    if (typeof command_obj.callback === 'function') {\n      command_obj.callback = batch_callback(self, command_obj.callback, index);\n    } else {\n      command_obj.callback = callback_without_own_cb;\n    }\n\n    if (typeof callback === 'function' && index === len - 1) {\n      command_obj.callback = last_callback(command_obj.callback);\n    }\n\n    this._client.internal_send_command(command_obj);\n\n    index++;\n  }\n\n  self._client.uncork();\n\n  return !self._client.should_buffer;\n};\n\nmodule.exports = Multi;","map":{"version":3,"sources":["/home/daniel/Projects/critter-catcher/node_modules/redis/lib/multi.js"],"names":["Queue","require","utils","Command","Multi","client","args","_client","queue","command","tmp_args","i","length","slice","Array","isArray","apply","concat","pipeline_transaction_command","self","command_obj","index","tmp","callback","err","reply","position","errors","push","wants_buffers","buffer_args","internal_send_command","prototype","exec_atomic","EXEC_ATOMIC","execAtomic","exec_batch","exec","multi_callback","replies","code","emit","shift","Error","match","message","err_code","toUpperCase","handle_reply","exec_transaction","monitoring","RangeError","reply_in_order","len","cork","get","uncork","should_buffer","batch_callback","cb","res","results","EXEC","callback_without_own_cb","last_callback","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Queue = require('denque');\nvar utils = require('./utils');\nvar Command = require('./command');\n\nfunction Multi (client, args) {\n    this._client = client;\n    this.queue = new Queue();\n    var command, tmp_args;\n    if (args) { // Either undefined or an array. Fail hard if it's not an array\n        for (var i = 0; i < args.length; i++) {\n            command = args[i][0];\n            tmp_args = args[i].slice(1);\n            if (Array.isArray(command)) {\n                this[command[0]].apply(this, command.slice(1).concat(tmp_args));\n            } else {\n                this[command].apply(this, tmp_args);\n            }\n        }\n    }\n}\n\nfunction pipeline_transaction_command (self, command_obj, index) {\n    // Queueing is done first, then the commands are executed\n    var tmp = command_obj.callback;\n    command_obj.callback = function (err, reply) {\n        // Ignore the multi command. This is applied by node_redis and the user does not benefit by it\n        if (err && index !== -1) {\n            if (tmp) {\n                tmp(err);\n            }\n            err.position = index;\n            self.errors.push(err);\n        }\n        // Keep track of who wants buffer responses:\n        // By the time the callback is called the command_obj got the buffer_args attribute attached\n        self.wants_buffers[index] = command_obj.buffer_args;\n        command_obj.callback = tmp;\n    };\n    self._client.internal_send_command(command_obj);\n}\n\nMulti.prototype.exec_atomic = Multi.prototype.EXEC_ATOMIC = Multi.prototype.execAtomic = function exec_atomic (callback) {\n    if (this.queue.length < 2) {\n        return this.exec_batch(callback);\n    }\n    return this.exec(callback);\n};\n\nfunction multi_callback (self, err, replies) {\n    var i = 0, command_obj;\n\n    if (err) {\n        err.errors = self.errors;\n        if (self.callback) {\n            self.callback(err);\n            // Exclude connection errors so that those errors won't be emitted twice\n        } else if (err.code !== 'CONNECTION_BROKEN') {\n            self._client.emit('error', err);\n        }\n        return;\n    }\n\n    if (replies) {\n        while (command_obj = self.queue.shift()) {\n            if (replies[i] instanceof Error) {\n                var match = replies[i].message.match(utils.err_code);\n                // LUA script could return user errors that don't behave like all other errors!\n                if (match) {\n                    replies[i].code = match[1];\n                }\n                replies[i].command = command_obj.command.toUpperCase();\n                if (typeof command_obj.callback === 'function') {\n                    command_obj.callback(replies[i]);\n                }\n            } else {\n                // If we asked for strings, even in detect_buffers mode, then return strings:\n                replies[i] = self._client.handle_reply(replies[i], command_obj.command, self.wants_buffers[i]);\n                if (typeof command_obj.callback === 'function') {\n                    command_obj.callback(null, replies[i]);\n                }\n            }\n            i++;\n        }\n    }\n\n    if (self.callback) {\n        self.callback(null, replies);\n    }\n}\n\nMulti.prototype.exec_transaction = function exec_transaction (callback) {\n    if (this.monitoring || this._client.monitoring) {\n        var err = new RangeError(\n            'Using transaction with a client that is in monitor mode does not work due to faulty return values of Redis.'\n        );\n        err.command = 'EXEC';\n        err.code = 'EXECABORT';\n        return utils.reply_in_order(this._client, callback, err);\n    }\n    var self = this;\n    var len = self.queue.length;\n    self.errors = [];\n    self.callback = callback;\n    self._client.cork();\n    self.wants_buffers = new Array(len);\n    pipeline_transaction_command(self, new Command('multi', []), -1);\n    // Drain queue, callback will catch 'QUEUED' or error\n    for (var index = 0; index < len; index++) {\n        // The commands may not be shifted off, since they are needed in the result handler\n        pipeline_transaction_command(self, self.queue.get(index), index);\n    }\n\n    self._client.internal_send_command(new Command('exec', [], function (err, replies) {\n        multi_callback(self, err, replies);\n    }));\n    self._client.uncork();\n    return !self._client.should_buffer;\n};\n\nfunction batch_callback (self, cb, i) {\n    return function batch_callback (err, res) {\n        if (err) {\n            self.results[i] = err;\n            // Add the position to the error\n            self.results[i].position = i;\n        } else {\n            self.results[i] = res;\n        }\n        cb(err, res);\n    };\n}\n\nMulti.prototype.exec = Multi.prototype.EXEC = Multi.prototype.exec_batch = function exec_batch (callback) {\n    var self = this;\n    var len = self.queue.length;\n    var index = 0;\n    var command_obj;\n    if (len === 0) {\n        utils.reply_in_order(self._client, callback, null, []);\n        return !self._client.should_buffer;\n    }\n    self._client.cork();\n    if (!callback) {\n        while (command_obj = self.queue.shift()) {\n            self._client.internal_send_command(command_obj);\n        }\n        self._client.uncork();\n        return !self._client.should_buffer;\n    }\n    var callback_without_own_cb = function (err, res) {\n        if (err) {\n            self.results.push(err);\n            // Add the position to the error\n            var i = self.results.length - 1;\n            self.results[i].position = i;\n        } else {\n            self.results.push(res);\n        }\n        // Do not emit an error here. Otherwise each error would result in one emit.\n        // The errors will be returned in the result anyway\n    };\n    var last_callback = function (cb) {\n        return function (err, res) {\n            cb(err, res);\n            callback(null, self.results);\n        };\n    };\n    self.results = [];\n    while (command_obj = self.queue.shift()) {\n        if (typeof command_obj.callback === 'function') {\n            command_obj.callback = batch_callback(self, command_obj.callback, index);\n        } else {\n            command_obj.callback = callback_without_own_cb;\n        }\n        if (typeof callback === 'function' && index === len - 1) {\n            command_obj.callback = last_callback(command_obj.callback);\n        }\n        this._client.internal_send_command(command_obj);\n        index++;\n    }\n    self._client.uncork();\n    return !self._client.should_buffer;\n};\n\nmodule.exports = Multi;\n"]},"metadata":{},"sourceType":"script"}