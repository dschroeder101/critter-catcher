{"ast":null,"code":"'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\nconst StringDecoder = require('string_decoder').StringDecoder;\n\nconst decoder = new StringDecoder();\n\nconst errors = require('redis-errors');\n\nconst ReplyError = errors.ReplyError;\nconst ParserError = errors.ParserError;\nvar bufferPool = Buffer.allocUnsafe(32 * 1024);\nvar bufferOffset = 0;\nvar interval = null;\nvar counter = 0;\nvar notDecreased = 0;\n/**\n * Used for integer numbers only\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\n\nfunction parseSimpleNumbers(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n  var sign = 1;\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1;\n    offset++;\n  }\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n      return sign * number;\n    }\n\n    number = number * 10 + (c1 - 48);\n  }\n}\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * Reading the string as parts of n SMI is more efficient than\n * using a string directly.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string}\n */\n\n\nfunction parseStringNumbers(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n  var res = '';\n\n  if (parser.buffer[offset] === 45) {\n    res += '-';\n    offset++;\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n\n      if (number !== 0) {\n        res += number;\n      }\n\n      return res;\n    } else if (number > 429496728) {\n      res += number * 10 + (c1 - 48);\n      number = 0;\n    } else if (c1 === 48 && number === 0) {\n      res += 0;\n    } else {\n      number = number * 10 + (c1 - 48);\n    }\n  }\n}\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string|Buffer}\n */\n\n\nfunction parseSimpleString(parser) {\n  const start = parser.offset;\n  const buffer = parser.buffer;\n  const length = buffer.length - 1;\n  var offset = start;\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) {\n      // \\r\\n\n      parser.offset = offset + 1;\n\n      if (parser.optionReturnBuffers === true) {\n        return parser.buffer.slice(start, offset - 1);\n      }\n\n      return parser.buffer.toString('utf8', start, offset - 1);\n    }\n  }\n}\n/**\n * Returns the read length\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\n\n\nfunction parseLength(parser) {\n  const length = parser.buffer.length - 1;\n  var offset = parser.offset;\n  var number = 0;\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++];\n\n    if (c1 === 13) {\n      parser.offset = offset + 1;\n      return number;\n    }\n\n    number = number * 10 + (c1 - 48);\n  }\n}\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number|string}\n */\n\n\nfunction parseInteger(parser) {\n  if (parser.optionStringNumbers === true) {\n    return parseStringNumbers(parser);\n  }\n\n  return parseSimpleNumbers(parser);\n}\n/**\n * Parse a '$' redis bulk string response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|string}\n */\n\n\nfunction parseBulkString(parser) {\n  const length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length < 0) {\n    return null;\n  }\n\n  const offset = parser.offset + length;\n\n  if (offset + 2 > parser.buffer.length) {\n    parser.bigStrSize = offset + 2;\n    parser.totalChunkSize = parser.buffer.length;\n    parser.bufferCache.push(parser.buffer);\n    return;\n  }\n\n  const start = parser.offset;\n  parser.offset = offset + 2;\n\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, offset);\n  }\n\n  return parser.buffer.toString('utf8', start, offset);\n}\n/**\n * Parse a '-' redis error response\n * @param {JavascriptRedisParser} parser\n * @returns {ReplyError}\n */\n\n\nfunction parseError(parser) {\n  var string = parseSimpleString(parser);\n\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString();\n    }\n\n    return new ReplyError(string);\n  }\n}\n/**\n * Parsing error handler, resets parser buffer\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {undefined}\n */\n\n\nfunction handleError(parser, type) {\n  const err = new ParserError('Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte', JSON.stringify(parser.buffer), parser.offset);\n  parser.buffer = null;\n  parser.returnFatalError(err);\n}\n/**\n * Parse a '*' redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|any[]}\n */\n\n\nfunction parseArray(parser) {\n  const length = parseLength(parser);\n\n  if (length === undefined) {\n    return;\n  }\n\n  if (length < 0) {\n    return null;\n  }\n\n  const responses = new Array(length);\n  return parseArrayElements(parser, responses, 0);\n}\n/**\n * Push a partly parsed array to the stack\n *\n * @param {JavascriptRedisParser} parser\n * @param {any[]} array\n * @param {number} pos\n * @returns {undefined}\n */\n\n\nfunction pushArrayCache(parser, array, pos) {\n  parser.arrayCache.push(array);\n  parser.arrayPos.push(pos);\n}\n/**\n * Parse chunked redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|any[]}\n */\n\n\nfunction parseArrayChunks(parser) {\n  const tmp = parser.arrayCache.pop();\n  var pos = parser.arrayPos.pop();\n\n  if (parser.arrayCache.length) {\n    const res = parseArrayChunks(parser);\n\n    if (res === undefined) {\n      pushArrayCache(parser, tmp, pos);\n      return;\n    }\n\n    tmp[pos++] = res;\n  }\n\n  return parseArrayElements(parser, tmp, pos);\n}\n/**\n * Parse redis array response elements\n * @param {JavascriptRedisParser} parser\n * @param {Array} responses\n * @param {number} i\n * @returns {undefined|null|any[]}\n */\n\n\nfunction parseArrayElements(parser, responses, i) {\n  const bufferLength = parser.buffer.length;\n\n  while (i < responses.length) {\n    const offset = parser.offset;\n\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    const response = parseType(parser, parser.buffer[parser.offset++]);\n\n    if (response === undefined) {\n      if (!(parser.arrayCache.length || parser.bufferCache.length)) {\n        parser.offset = offset;\n      }\n\n      pushArrayCache(parser, responses, i);\n      return;\n    }\n\n    responses[i] = response;\n    i++;\n  }\n\n  return responses;\n}\n/**\n * Called the appropriate parser for the specified type.\n *\n * 36: $\n * 43: +\n * 42: *\n * 58: :\n * 45: -\n *\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {*}\n */\n\n\nfunction parseType(parser, type) {\n  switch (type) {\n    case 36:\n      return parseBulkString(parser);\n\n    case 43:\n      return parseSimpleString(parser);\n\n    case 42:\n      return parseArray(parser);\n\n    case 58:\n      return parseInteger(parser);\n\n    case 45:\n      return parseError(parser);\n\n    default:\n      return handleError(parser, type);\n  }\n}\n/**\n * Decrease the bufferPool size over time\n *\n * Balance between increasing and decreasing the bufferPool.\n * Decrease the bufferPool by 10% by removing the first 10% of the current pool.\n * @returns {undefined}\n */\n\n\nfunction decreaseBufferPool() {\n  if (bufferPool.length > 50 * 1024) {\n    if (counter === 1 || notDecreased > counter * 2) {\n      const minSliceLen = Math.floor(bufferPool.length / 10);\n      const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;\n      bufferOffset = 0;\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length);\n    } else {\n      notDecreased++;\n      counter--;\n    }\n  } else {\n    clearInterval(interval);\n    counter = 0;\n    notDecreased = 0;\n    interval = null;\n  }\n}\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param {number} length\n * @returns {undefined}\n */\n\n\nfunction resizeBuffer(length) {\n  if (bufferPool.length < length + bufferOffset) {\n    const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;\n\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50;\n    }\n\n    bufferPool = Buffer.allocUnsafe(length * multiplier + bufferOffset);\n    bufferOffset = 0;\n    counter++;\n\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50);\n    }\n  }\n}\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param {JavascriptRedisParser} parser\n * @returns {String}\n */\n\n\nfunction concatBulkString(parser) {\n  const list = parser.bufferCache;\n  const oldOffset = parser.offset;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', oldOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  var res = decoder.write(list[0].slice(oldOffset));\n\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i]);\n  }\n\n  res += decoder.end(list[i].slice(0, offset - 2));\n  return res;\n}\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {Buffer}\n */\n\n\nfunction concatBulkBuffer(parser) {\n  const list = parser.bufferCache;\n  const oldOffset = parser.offset;\n  const length = parser.bigStrSize - oldOffset - 2;\n  var chunks = list.length;\n  var offset = parser.bigStrSize - parser.totalChunkSize;\n  parser.offset = offset;\n\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(oldOffset, list[0].length + offset - 2);\n    }\n\n    chunks--;\n    offset = list[list.length - 2].length + offset;\n  }\n\n  resizeBuffer(length);\n  const start = bufferOffset;\n  list[0].copy(bufferPool, start, oldOffset, list[0].length);\n  bufferOffset += list[0].length - oldOffset;\n\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset);\n    bufferOffset += list[i].length;\n  }\n\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2);\n  bufferOffset += offset - 2;\n  return bufferPool.slice(start, bufferOffset);\n}\n\nclass JavascriptRedisParser {\n  /**\n   * Javascript Redis Parser constructor\n   * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options\n   * @constructor\n   */\n  constructor(options) {\n    if (!options) {\n      throw new TypeError('Options are mandatory.');\n    }\n\n    if (typeof options.returnError !== 'function' || typeof options.returnReply !== 'function') {\n      throw new TypeError('The returnReply and returnError options have to be functions.');\n    }\n\n    this.setReturnBuffers(!!options.returnBuffers);\n    this.setStringNumbers(!!options.stringNumbers);\n    this.returnError = options.returnError;\n    this.returnFatalError = options.returnFatalError || options.returnError;\n    this.returnReply = options.returnReply;\n    this.reset();\n  }\n  /**\n   * Reset the parser values to the initial state\n   *\n   * @returns {undefined}\n   */\n\n\n  reset() {\n    this.offset = 0;\n    this.buffer = null;\n    this.bigStrSize = 0;\n    this.totalChunkSize = 0;\n    this.bufferCache = [];\n    this.arrayCache = [];\n    this.arrayPos = [];\n  }\n  /**\n   * Set the returnBuffers option\n   *\n   * @param {boolean} returnBuffers\n   * @returns {undefined}\n   */\n\n\n  setReturnBuffers(returnBuffers) {\n    if (typeof returnBuffers !== 'boolean') {\n      throw new TypeError('The returnBuffers argument has to be a boolean');\n    }\n\n    this.optionReturnBuffers = returnBuffers;\n  }\n  /**\n   * Set the stringNumbers option\n   *\n   * @param {boolean} stringNumbers\n   * @returns {undefined}\n   */\n\n\n  setStringNumbers(stringNumbers) {\n    if (typeof stringNumbers !== 'boolean') {\n      throw new TypeError('The stringNumbers argument has to be a boolean');\n    }\n\n    this.optionStringNumbers = stringNumbers;\n  }\n  /**\n   * Parse the redis buffer\n   * @param {Buffer} buffer\n   * @returns {undefined}\n   */\n\n\n  execute(buffer) {\n    if (this.buffer === null) {\n      this.buffer = buffer;\n      this.offset = 0;\n    } else if (this.bigStrSize === 0) {\n      const oldLength = this.buffer.length;\n      const remainingLength = oldLength - this.offset;\n      const newBuffer = Buffer.allocUnsafe(remainingLength + buffer.length);\n      this.buffer.copy(newBuffer, 0, this.offset, oldLength);\n      buffer.copy(newBuffer, remainingLength, 0, buffer.length);\n      this.buffer = newBuffer;\n      this.offset = 0;\n\n      if (this.arrayCache.length) {\n        const arr = parseArrayChunks(this);\n\n        if (arr === undefined) {\n          return;\n        }\n\n        this.returnReply(arr);\n      }\n    } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n      this.bufferCache.push(buffer);\n      var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);\n      this.bigStrSize = 0;\n      this.bufferCache = [];\n      this.buffer = buffer;\n\n      if (this.arrayCache.length) {\n        this.arrayCache[0][this.arrayPos[0]++] = tmp;\n        tmp = parseArrayChunks(this);\n\n        if (tmp === undefined) {\n          return;\n        }\n      }\n\n      this.returnReply(tmp);\n    } else {\n      this.bufferCache.push(buffer);\n      this.totalChunkSize += buffer.length;\n      return;\n    }\n\n    while (this.offset < this.buffer.length) {\n      const offset = this.offset;\n      const type = this.buffer[this.offset++];\n      const response = parseType(this, type);\n\n      if (response === undefined) {\n        if (!(this.arrayCache.length || this.bufferCache.length)) {\n          this.offset = offset;\n        }\n\n        return;\n      }\n\n      if (type === 45) {\n        this.returnError(response);\n      } else {\n        this.returnReply(response);\n      }\n    }\n\n    this.buffer = null;\n  }\n\n}\n\nmodule.exports = JavascriptRedisParser;","map":{"version":3,"sources":["/home/daniel/Projects/critter-catcher/node_modules/redis-parser/lib/parser.js"],"names":["Buffer","require","StringDecoder","decoder","errors","ReplyError","ParserError","bufferPool","allocUnsafe","bufferOffset","interval","counter","notDecreased","parseSimpleNumbers","parser","length","buffer","offset","number","sign","c1","parseStringNumbers","res","parseSimpleString","start","optionReturnBuffers","slice","toString","parseLength","parseInteger","optionStringNumbers","parseBulkString","undefined","bigStrSize","totalChunkSize","bufferCache","push","parseError","string","handleError","type","err","JSON","stringify","String","fromCharCode","returnFatalError","parseArray","responses","Array","parseArrayElements","pushArrayCache","array","pos","arrayCache","arrayPos","parseArrayChunks","tmp","pop","i","bufferLength","response","parseType","decreaseBufferPool","minSliceLen","Math","floor","sliceLength","clearInterval","resizeBuffer","multiplier","setInterval","concatBulkString","list","oldOffset","chunks","write","end","concatBulkBuffer","copy","JavascriptRedisParser","constructor","options","TypeError","returnError","returnReply","setReturnBuffers","returnBuffers","setStringNumbers","stringNumbers","reset","execute","oldLength","remainingLength","newBuffer","arr","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Buffer = require('buffer').Buffer\nconst StringDecoder = require('string_decoder').StringDecoder\nconst decoder = new StringDecoder()\nconst errors = require('redis-errors')\nconst ReplyError = errors.ReplyError\nconst ParserError = errors.ParserError\nvar bufferPool = Buffer.allocUnsafe(32 * 1024)\nvar bufferOffset = 0\nvar interval = null\nvar counter = 0\nvar notDecreased = 0\n\n/**\n * Used for integer numbers only\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseSimpleNumbers (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n  var sign = 1\n\n  if (parser.buffer[offset] === 45) {\n    sign = -1\n    offset++\n  }\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      return sign * number\n    }\n    number = (number * 10) + (c1 - 48)\n  }\n}\n\n/**\n * Used for integer numbers in case of the returnNumbers option\n *\n * Reading the string as parts of n SMI is more efficient than\n * using a string directly.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string}\n */\nfunction parseStringNumbers (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n  var res = ''\n\n  if (parser.buffer[offset] === 45) {\n    res += '-'\n    offset++\n  }\n\n  while (offset < length) {\n    var c1 = parser.buffer[offset++]\n    if (c1 === 13) { // \\r\\n\n      parser.offset = offset + 1\n      if (number !== 0) {\n        res += number\n      }\n      return res\n    } else if (number > 429496728) {\n      res += (number * 10) + (c1 - 48)\n      number = 0\n    } else if (c1 === 48 && number === 0) {\n      res += 0\n    } else {\n      number = (number * 10) + (c1 - 48)\n    }\n  }\n}\n\n/**\n * Parse a '+' redis simple string response but forward the offsets\n * onto convertBufferRange to generate a string.\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|string|Buffer}\n */\nfunction parseSimpleString (parser) {\n  const start = parser.offset\n  const buffer = parser.buffer\n  const length = buffer.length - 1\n  var offset = start\n\n  while (offset < length) {\n    if (buffer[offset++] === 13) { // \\r\\n\n      parser.offset = offset + 1\n      if (parser.optionReturnBuffers === true) {\n        return parser.buffer.slice(start, offset - 1)\n      }\n      return parser.buffer.toString('utf8', start, offset - 1)\n    }\n  }\n}\n\n/**\n * Returns the read length\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number}\n */\nfunction parseLength (parser) {\n  const length = parser.buffer.length - 1\n  var offset = parser.offset\n  var number = 0\n\n  while (offset < length) {\n    const c1 = parser.buffer[offset++]\n    if (c1 === 13) {\n      parser.offset = offset + 1\n      return number\n    }\n    number = (number * 10) + (c1 - 48)\n  }\n}\n\n/**\n * Parse a ':' redis integer response\n *\n * If stringNumbers is activated the parser always returns numbers as string\n * This is important for big numbers (number > Math.pow(2, 53)) as js numbers\n * are 64bit floating point numbers with reduced precision\n *\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|number|string}\n */\nfunction parseInteger (parser) {\n  if (parser.optionStringNumbers === true) {\n    return parseStringNumbers(parser)\n  }\n  return parseSimpleNumbers(parser)\n}\n\n/**\n * Parse a '$' redis bulk string response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|string}\n */\nfunction parseBulkString (parser) {\n  const length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length < 0) {\n    return null\n  }\n  const offset = parser.offset + length\n  if (offset + 2 > parser.buffer.length) {\n    parser.bigStrSize = offset + 2\n    parser.totalChunkSize = parser.buffer.length\n    parser.bufferCache.push(parser.buffer)\n    return\n  }\n  const start = parser.offset\n  parser.offset = offset + 2\n  if (parser.optionReturnBuffers === true) {\n    return parser.buffer.slice(start, offset)\n  }\n  return parser.buffer.toString('utf8', start, offset)\n}\n\n/**\n * Parse a '-' redis error response\n * @param {JavascriptRedisParser} parser\n * @returns {ReplyError}\n */\nfunction parseError (parser) {\n  var string = parseSimpleString(parser)\n  if (string !== undefined) {\n    if (parser.optionReturnBuffers === true) {\n      string = string.toString()\n    }\n    return new ReplyError(string)\n  }\n}\n\n/**\n * Parsing error handler, resets parser buffer\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {undefined}\n */\nfunction handleError (parser, type) {\n  const err = new ParserError(\n    'Protocol error, got ' + JSON.stringify(String.fromCharCode(type)) + ' as reply type byte',\n    JSON.stringify(parser.buffer),\n    parser.offset\n  )\n  parser.buffer = null\n  parser.returnFatalError(err)\n}\n\n/**\n * Parse a '*' redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|null|any[]}\n */\nfunction parseArray (parser) {\n  const length = parseLength(parser)\n  if (length === undefined) {\n    return\n  }\n  if (length < 0) {\n    return null\n  }\n  const responses = new Array(length)\n  return parseArrayElements(parser, responses, 0)\n}\n\n/**\n * Push a partly parsed array to the stack\n *\n * @param {JavascriptRedisParser} parser\n * @param {any[]} array\n * @param {number} pos\n * @returns {undefined}\n */\nfunction pushArrayCache (parser, array, pos) {\n  parser.arrayCache.push(array)\n  parser.arrayPos.push(pos)\n}\n\n/**\n * Parse chunked redis array response\n * @param {JavascriptRedisParser} parser\n * @returns {undefined|any[]}\n */\nfunction parseArrayChunks (parser) {\n  const tmp = parser.arrayCache.pop()\n  var pos = parser.arrayPos.pop()\n  if (parser.arrayCache.length) {\n    const res = parseArrayChunks(parser)\n    if (res === undefined) {\n      pushArrayCache(parser, tmp, pos)\n      return\n    }\n    tmp[pos++] = res\n  }\n  return parseArrayElements(parser, tmp, pos)\n}\n\n/**\n * Parse redis array response elements\n * @param {JavascriptRedisParser} parser\n * @param {Array} responses\n * @param {number} i\n * @returns {undefined|null|any[]}\n */\nfunction parseArrayElements (parser, responses, i) {\n  const bufferLength = parser.buffer.length\n  while (i < responses.length) {\n    const offset = parser.offset\n    if (parser.offset >= bufferLength) {\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    const response = parseType(parser, parser.buffer[parser.offset++])\n    if (response === undefined) {\n      if (!(parser.arrayCache.length || parser.bufferCache.length)) {\n        parser.offset = offset\n      }\n      pushArrayCache(parser, responses, i)\n      return\n    }\n    responses[i] = response\n    i++\n  }\n\n  return responses\n}\n\n/**\n * Called the appropriate parser for the specified type.\n *\n * 36: $\n * 43: +\n * 42: *\n * 58: :\n * 45: -\n *\n * @param {JavascriptRedisParser} parser\n * @param {number} type\n * @returns {*}\n */\nfunction parseType (parser, type) {\n  switch (type) {\n    case 36:\n      return parseBulkString(parser)\n    case 43:\n      return parseSimpleString(parser)\n    case 42:\n      return parseArray(parser)\n    case 58:\n      return parseInteger(parser)\n    case 45:\n      return parseError(parser)\n    default:\n      return handleError(parser, type)\n  }\n}\n\n/**\n * Decrease the bufferPool size over time\n *\n * Balance between increasing and decreasing the bufferPool.\n * Decrease the bufferPool by 10% by removing the first 10% of the current pool.\n * @returns {undefined}\n */\nfunction decreaseBufferPool () {\n  if (bufferPool.length > 50 * 1024) {\n    if (counter === 1 || notDecreased > counter * 2) {\n      const minSliceLen = Math.floor(bufferPool.length / 10)\n      const sliceLength = minSliceLen < bufferOffset\n        ? bufferOffset\n        : minSliceLen\n      bufferOffset = 0\n      bufferPool = bufferPool.slice(sliceLength, bufferPool.length)\n    } else {\n      notDecreased++\n      counter--\n    }\n  } else {\n    clearInterval(interval)\n    counter = 0\n    notDecreased = 0\n    interval = null\n  }\n}\n\n/**\n * Check if the requested size fits in the current bufferPool.\n * If it does not, reset and increase the bufferPool accordingly.\n *\n * @param {number} length\n * @returns {undefined}\n */\nfunction resizeBuffer (length) {\n  if (bufferPool.length < length + bufferOffset) {\n    const multiplier = length > 1024 * 1024 * 75 ? 2 : 3\n    if (bufferOffset > 1024 * 1024 * 111) {\n      bufferOffset = 1024 * 1024 * 50\n    }\n    bufferPool = Buffer.allocUnsafe(length * multiplier + bufferOffset)\n    bufferOffset = 0\n    counter++\n    if (interval === null) {\n      interval = setInterval(decreaseBufferPool, 50)\n    }\n  }\n}\n\n/**\n * Concat a bulk string containing multiple chunks\n *\n * Notes:\n * 1) The first chunk might contain the whole bulk string including the \\r\n * 2) We are only safe to fully add up elements that are neither the first nor any of the last two elements\n *\n * @param {JavascriptRedisParser} parser\n * @returns {String}\n */\nfunction concatBulkString (parser) {\n  const list = parser.bufferCache\n  const oldOffset = parser.offset\n  var chunks = list.length\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].toString('utf8', oldOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  var res = decoder.write(list[0].slice(oldOffset))\n  for (var i = 1; i < chunks - 1; i++) {\n    res += decoder.write(list[i])\n  }\n  res += decoder.end(list[i].slice(0, offset - 2))\n  return res\n}\n\n/**\n * Concat the collected chunks from parser.bufferCache.\n *\n * Increases the bufferPool size beforehand if necessary.\n *\n * @param {JavascriptRedisParser} parser\n * @returns {Buffer}\n */\nfunction concatBulkBuffer (parser) {\n  const list = parser.bufferCache\n  const oldOffset = parser.offset\n  const length = parser.bigStrSize - oldOffset - 2\n  var chunks = list.length\n  var offset = parser.bigStrSize - parser.totalChunkSize\n  parser.offset = offset\n  if (offset <= 2) {\n    if (chunks === 2) {\n      return list[0].slice(oldOffset, list[0].length + offset - 2)\n    }\n    chunks--\n    offset = list[list.length - 2].length + offset\n  }\n  resizeBuffer(length)\n  const start = bufferOffset\n  list[0].copy(bufferPool, start, oldOffset, list[0].length)\n  bufferOffset += list[0].length - oldOffset\n  for (var i = 1; i < chunks - 1; i++) {\n    list[i].copy(bufferPool, bufferOffset)\n    bufferOffset += list[i].length\n  }\n  list[i].copy(bufferPool, bufferOffset, 0, offset - 2)\n  bufferOffset += offset - 2\n  return bufferPool.slice(start, bufferOffset)\n}\n\nclass JavascriptRedisParser {\n  /**\n   * Javascript Redis Parser constructor\n   * @param {{returnError: Function, returnReply: Function, returnFatalError?: Function, returnBuffers: boolean, stringNumbers: boolean }} options\n   * @constructor\n   */\n  constructor (options) {\n    if (!options) {\n      throw new TypeError('Options are mandatory.')\n    }\n    if (typeof options.returnError !== 'function' || typeof options.returnReply !== 'function') {\n      throw new TypeError('The returnReply and returnError options have to be functions.')\n    }\n    this.setReturnBuffers(!!options.returnBuffers)\n    this.setStringNumbers(!!options.stringNumbers)\n    this.returnError = options.returnError\n    this.returnFatalError = options.returnFatalError || options.returnError\n    this.returnReply = options.returnReply\n    this.reset()\n  }\n\n  /**\n   * Reset the parser values to the initial state\n   *\n   * @returns {undefined}\n   */\n  reset () {\n    this.offset = 0\n    this.buffer = null\n    this.bigStrSize = 0\n    this.totalChunkSize = 0\n    this.bufferCache = []\n    this.arrayCache = []\n    this.arrayPos = []\n  }\n\n  /**\n   * Set the returnBuffers option\n   *\n   * @param {boolean} returnBuffers\n   * @returns {undefined}\n   */\n  setReturnBuffers (returnBuffers) {\n    if (typeof returnBuffers !== 'boolean') {\n      throw new TypeError('The returnBuffers argument has to be a boolean')\n    }\n    this.optionReturnBuffers = returnBuffers\n  }\n\n  /**\n   * Set the stringNumbers option\n   *\n   * @param {boolean} stringNumbers\n   * @returns {undefined}\n   */\n  setStringNumbers (stringNumbers) {\n    if (typeof stringNumbers !== 'boolean') {\n      throw new TypeError('The stringNumbers argument has to be a boolean')\n    }\n    this.optionStringNumbers = stringNumbers\n  }\n\n  /**\n   * Parse the redis buffer\n   * @param {Buffer} buffer\n   * @returns {undefined}\n   */\n  execute (buffer) {\n    if (this.buffer === null) {\n      this.buffer = buffer\n      this.offset = 0\n    } else if (this.bigStrSize === 0) {\n      const oldLength = this.buffer.length\n      const remainingLength = oldLength - this.offset\n      const newBuffer = Buffer.allocUnsafe(remainingLength + buffer.length)\n      this.buffer.copy(newBuffer, 0, this.offset, oldLength)\n      buffer.copy(newBuffer, remainingLength, 0, buffer.length)\n      this.buffer = newBuffer\n      this.offset = 0\n      if (this.arrayCache.length) {\n        const arr = parseArrayChunks(this)\n        if (arr === undefined) {\n          return\n        }\n        this.returnReply(arr)\n      }\n    } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {\n      this.bufferCache.push(buffer)\n      var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this)\n      this.bigStrSize = 0\n      this.bufferCache = []\n      this.buffer = buffer\n      if (this.arrayCache.length) {\n        this.arrayCache[0][this.arrayPos[0]++] = tmp\n        tmp = parseArrayChunks(this)\n        if (tmp === undefined) {\n          return\n        }\n      }\n      this.returnReply(tmp)\n    } else {\n      this.bufferCache.push(buffer)\n      this.totalChunkSize += buffer.length\n      return\n    }\n\n    while (this.offset < this.buffer.length) {\n      const offset = this.offset\n      const type = this.buffer[this.offset++]\n      const response = parseType(this, type)\n      if (response === undefined) {\n        if (!(this.arrayCache.length || this.bufferCache.length)) {\n          this.offset = offset\n        }\n        return\n      }\n\n      if (type === 45) {\n        this.returnError(response)\n      } else {\n        this.returnReply(response)\n      }\n    }\n\n    this.buffer = null\n  }\n}\n\nmodule.exports = JavascriptRedisParser\n"]},"metadata":{},"sourceType":"script"}